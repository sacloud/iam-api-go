// Code generated by ogen, DO NOT EDIT.

package v1

import (
	"fmt"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/ogen-go/ogen/validate"

	std "encoding/json"
	"testing"

	"github.com/stretchr/testify/require"
)

func TestAuthConditions_EncodeDecode(t *testing.T) {
	var typ AuthConditions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AuthConditions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestAuthConditions_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"datetime_restriction\":{\"after\":\"2025-09-01T00:00:00+09:00\",\"before\":\"2025-10-01T00:00:00+09:00\"},\"ip_restriction\":{\"mode\":\"allow_all\"},\"require_two_factor_auth\":{\"enabled\":false}}"},
		{Input: "{\"datetime_restriction\":{\"after\":\"2025-09-01T00:00:00+09:00\",\"before\":\"2025-10-01T00:00:00+09:00\"},\"ip_restriction\":{\"mode\":\"allow_list\",\"source_network\":[\"192.0.2.0/24\",\"198.51.100.0/24\",\"203.0.113.0/24\"]},\"require_two_factor_auth\":{\"enabled\":false}}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ AuthConditions

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 AuthConditions
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestAuthConditionsDatetimeRestriction_EncodeDecode(t *testing.T) {
	var typ AuthConditionsDatetimeRestriction
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AuthConditionsDatetimeRestriction
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAuthConditionsIPRestriction_EncodeDecode(t *testing.T) {
	var typ AuthConditionsIPRestriction
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AuthConditionsIPRestriction
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAuthConditionsIPRestrictionMode_EncodeDecode(t *testing.T) {
	var typ AuthConditionsIPRestrictionMode
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AuthConditionsIPRestrictionMode
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAuthConditionsRequireTwoFactorAuth_EncodeDecode(t *testing.T) {
	var typ AuthConditionsRequireTwoFactorAuth
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AuthConditionsRequireTwoFactorAuth
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestAuthConditionsRequireTwoFactorAuth_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"enabled\":false}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ AuthConditionsRequireTwoFactorAuth

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 AuthConditionsRequireTwoFactorAuth
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCompatAPIKeysApikeyIDPutReq_EncodeDecode(t *testing.T) {
	var typ CompatAPIKeysApikeyIDPutReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CompatAPIKeysApikeyIDPutReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCompatAPIKeysGetOK_EncodeDecode(t *testing.T) {
	var typ CompatAPIKeysGetOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CompatAPIKeysGetOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCompatAPIKeysPostReq_EncodeDecode(t *testing.T) {
	var typ CompatAPIKeysPostReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CompatAPIKeysPostReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCompatUsersGetOK_EncodeDecode(t *testing.T) {
	var typ CompatUsersGetOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CompatUsersGetOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCompatUsersPostReq_EncodeDecode(t *testing.T) {
	var typ CompatUsersPostReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CompatUsersPostReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCompatUsersUserIDActivateOtpPostOK_EncodeDecode(t *testing.T) {
	var typ CompatUsersUserIDActivateOtpPostOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CompatUsersUserIDActivateOtpPostOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCompatUsersUserIDActivateOtpPostOKAlgorithm_EncodeDecode(t *testing.T) {
	var typ CompatUsersUserIDActivateOtpPostOKAlgorithm
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CompatUsersUserIDActivateOtpPostOKAlgorithm
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCompatUsersUserIDActivateOtpPostOKAlgorithm_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"sha1\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CompatUsersUserIDActivateOtpPostOKAlgorithm

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CompatUsersUserIDActivateOtpPostOKAlgorithm
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCompatUsersUserIDActivateOtpPostOKClass_EncodeDecode(t *testing.T) {
	var typ CompatUsersUserIDActivateOtpPostOKClass
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CompatUsersUserIDActivateOtpPostOKClass
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCompatUsersUserIDActivateOtpPostOKClass_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"totp\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ CompatUsersUserIDActivateOtpPostOKClass

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 CompatUsersUserIDActivateOtpPostOKClass
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCompatUsersUserIDPutReq_EncodeDecode(t *testing.T) {
	var typ CompatUsersUserIDPutReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CompatUsersUserIDPutReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCompatUsersUserIDRecoveryCodePostOK_EncodeDecode(t *testing.T) {
	var typ CompatUsersUserIDRecoveryCodePostOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CompatUsersUserIDRecoveryCodePostOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCompatUsersUserIDRegisterEmailPostReq_EncodeDecode(t *testing.T) {
	var typ CompatUsersUserIDRegisterEmailPostReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CompatUsersUserIDRegisterEmailPostReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCompatUsersUserIDSecurityKeysGetOK_EncodeDecode(t *testing.T) {
	var typ CompatUsersUserIDSecurityKeysGetOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CompatUsersUserIDSecurityKeysGetOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCompatUsersUserIDSecurityKeysSecurityKeyIDPutReq_EncodeDecode(t *testing.T) {
	var typ CompatUsersUserIDSecurityKeysSecurityKeyIDPutReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CompatUsersUserIDSecurityKeysSecurityKeyIDPutReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCompatUsersUserIDStartSecurityKeyRegistrationPostOK_EncodeDecode(t *testing.T) {
	var typ CompatUsersUserIDStartSecurityKeyRegistrationPostOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CompatUsersUserIDStartSecurityKeyRegistrationPostOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCompatUsersUserIDTrustedDevicesGetOK_EncodeDecode(t *testing.T) {
	var typ CompatUsersUserIDTrustedDevicesGetOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CompatUsersUserIDTrustedDevicesGetOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCompatUsersUserIDValidateSecurityKeyRegistrationPostReq_EncodeDecode(t *testing.T) {
	var typ CompatUsersUserIDValidateSecurityKeyRegistrationPostReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CompatUsersUserIDValidateSecurityKeyRegistrationPostReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFolder_EncodeDecode(t *testing.T) {
	var typ Folder
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Folder
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFoldersFolderIDIamPolicyGetOK_EncodeDecode(t *testing.T) {
	var typ FoldersFolderIDIamPolicyGetOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FoldersFolderIDIamPolicyGetOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestFoldersFolderIDIamPolicyGetOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"bindings\":[{\"principals\":[{\"id\":111111111111,\"type\":\"user\"},{\"id\":1,\"type\":\"group\"},{\"id\":111111111111,\"type\":\"service-principal\"}],\"role\":{\"id\":\"admin\",\"type\":\"preset\"}}]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ FoldersFolderIDIamPolicyGetOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 FoldersFolderIDIamPolicyGetOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestFoldersFolderIDIamPolicyPutOK_EncodeDecode(t *testing.T) {
	var typ FoldersFolderIDIamPolicyPutOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FoldersFolderIDIamPolicyPutOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFoldersFolderIDIamPolicyPutReq_EncodeDecode(t *testing.T) {
	var typ FoldersFolderIDIamPolicyPutReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FoldersFolderIDIamPolicyPutReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestFoldersFolderIDIamPolicyPutReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"bindings\":[{\"principals\":[{\"id\":111111111111,\"type\":\"user\"},{\"id\":1,\"type\":\"group\"},{\"id\":111111111111,\"type\":\"service-principal\"}],\"role\":{\"id\":\"admin\",\"type\":\"preset\"}}]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ FoldersFolderIDIamPolicyPutReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 FoldersFolderIDIamPolicyPutReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestFoldersFolderIDPutReq_EncodeDecode(t *testing.T) {
	var typ FoldersFolderIDPutReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FoldersFolderIDPutReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFoldersGetOK_EncodeDecode(t *testing.T) {
	var typ FoldersGetOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FoldersGetOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFoldersPostReq_EncodeDecode(t *testing.T) {
	var typ FoldersPostReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FoldersPostReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGroup_EncodeDecode(t *testing.T) {
	var typ Group
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Group
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGroupMemberships_EncodeDecode(t *testing.T) {
	var typ GroupMemberships
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GroupMemberships
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGroupMembershipsCompatUsersItem_EncodeDecode(t *testing.T) {
	var typ GroupMembershipsCompatUsersItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GroupMembershipsCompatUsersItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGroupsGetOK_EncodeDecode(t *testing.T) {
	var typ GroupsGetOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GroupsGetOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGroupsGroupIDMembershipsPutReq_EncodeDecode(t *testing.T) {
	var typ GroupsGroupIDMembershipsPutReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GroupsGroupIDMembershipsPutReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGroupsGroupIDMembershipsPutReqCompatUsersItem_EncodeDecode(t *testing.T) {
	var typ GroupsGroupIDMembershipsPutReqCompatUsersItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GroupsGroupIDMembershipsPutReqCompatUsersItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGroupsGroupIDPutReq_EncodeDecode(t *testing.T) {
	var typ GroupsGroupIDPutReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GroupsGroupIDPutReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGroupsPostReq_EncodeDecode(t *testing.T) {
	var typ GroupsPostReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GroupsPostReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHttp400BadRequest_EncodeDecode(t *testing.T) {
	var typ Http400BadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Http400BadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestHttp400BadRequest_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"detail\":\"フォルダの登録数上限◯◯を超えています。\",\"status\":400,\"title\":\"folder_registration_limit_over\"}"},
		{Input: "{\"detail\":\"下の階層にフォルダまたはプロジェクトがあります。\",\"status\":400,\"title\":\"exist_dependency_folders_or_projects\",\"type\":\"about:blank\"}"},
		{Input: "{\"detail\":\"同じ階層に同じ名前のフォルダを登録できません。\",\"status\":400,\"title\":\"duplicate_folder_names\",\"type\":\"about:blank\"}"},
		{Input: "{\"detail\":\"同じ階層に同じ名前のフォルダを登録できません。\\nフォルダ名を変更してください。\\n\",\"status\":400,\"title\":\"duplicate_folder_names\",\"type\":\"about:blank\"}"},
		{Input: "{\"detail\":\"同じ階層に同じ名前のプロジェクトを登録できません。\",\"status\":400,\"title\":\"duplicate_project_names\",\"type\":\"about:blank\"}"},
		{Input: "{\"detail\":\"指定されたフォルダが見つかりません\",\"status\":400,\"title\":\"folder_not_found\",\"type\":\"about:blank\"}"},
		{Input: "{\"detail\":\"指定されたプロジェクトが見つかりません。\",\"status\":400,\"title\":\"project_not_found\",\"type\":\"about:blank\"}"},
		{Input: "{\"detail\":\"親フォルダが見つかりません。\",\"status\":400,\"title\":\"parant_not_found\",\"type\":\"about:blank\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Http400BadRequest

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Http400BadRequest
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestHttp400BadRequestErrors_EncodeDecode(t *testing.T) {
	var typ Http400BadRequestErrors
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Http400BadRequestErrors
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestHttp400BadRequestErrors_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"key1\":[{\"code\":\"required\",\"message\":\"この項目は必須です。\"}],\"key2\":[{\"code\":\"invalid\",\"message\":\"有効な値ではありません。\"}],\"key3\":[{\"code\":\"min_length\",\"message\":\"この項目は少なくとも*文字以上にしてください。\"}],\"key4\":[{\"code\":\"max_length\",\"message\":\"この項目が*文字より長くならないようにしてください。\"}]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Http400BadRequestErrors

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Http400BadRequestErrors
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestHttp400BadRequestErrorsAdditional_EncodeDecode(t *testing.T) {
	var typ Http400BadRequestErrorsAdditional
	typ = make(Http400BadRequestErrorsAdditional)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Http400BadRequestErrorsAdditional
	typ2 = make(Http400BadRequestErrorsAdditional)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHttp400BadRequestErrorsAdditionalItemItem_EncodeDecode(t *testing.T) {
	var typ Http400BadRequestErrorsAdditionalItemItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Http400BadRequestErrorsAdditionalItemItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHttp400BadRequestErrorsNonFieldErrorsItem_EncodeDecode(t *testing.T) {
	var typ Http400BadRequestErrorsNonFieldErrorsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Http400BadRequestErrorsNonFieldErrorsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHttp401Unauthorized_EncodeDecode(t *testing.T) {
	var typ Http401Unauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Http401Unauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHttp403Forbidden_EncodeDecode(t *testing.T) {
	var typ Http403Forbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Http403Forbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHttp404NotFound_EncodeDecode(t *testing.T) {
	var typ Http404NotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Http404NotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHttp409Conflict_EncodeDecode(t *testing.T) {
	var typ Http409Conflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Http409Conflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHttp429TooManyRequests_EncodeDecode(t *testing.T) {
	var typ Http429TooManyRequests
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Http429TooManyRequests
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHttp503ServiceUnavailable_EncodeDecode(t *testing.T) {
	var typ Http503ServiceUnavailable
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Http503ServiceUnavailable
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIDRolesGetOK_EncodeDecode(t *testing.T) {
	var typ IDRolesGetOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IDRolesGetOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIamPolicy_EncodeDecode(t *testing.T) {
	var typ IamPolicy
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IamPolicy
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIamPolicyRole_EncodeDecode(t *testing.T) {
	var typ IamPolicyRole
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IamPolicyRole
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIamPolicyRoleType_EncodeDecode(t *testing.T) {
	var typ IamPolicyRoleType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IamPolicyRoleType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIamRole_EncodeDecode(t *testing.T) {
	var typ IamRole
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IamRole
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIamRolesGetOK_EncodeDecode(t *testing.T) {
	var typ IamRolesGetOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IamRolesGetOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIdPolicy_EncodeDecode(t *testing.T) {
	var typ IdPolicy
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IdPolicy
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIdPolicyRole_EncodeDecode(t *testing.T) {
	var typ IdPolicyRole
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IdPolicyRole
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIdPolicyRoleType_EncodeDecode(t *testing.T) {
	var typ IdPolicyRoleType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IdPolicyRoleType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIdRole_EncodeDecode(t *testing.T) {
	var typ IdRole
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IdRole
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMoveFolders_EncodeDecode(t *testing.T) {
	var typ MoveFolders
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MoveFolders
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMoveProjects_EncodeDecode(t *testing.T) {
	var typ MoveProjects
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MoveProjects
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOrganization_EncodeDecode(t *testing.T) {
	var typ Organization
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Organization
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOrganizationIDPolicyGetOK_EncodeDecode(t *testing.T) {
	var typ OrganizationIDPolicyGetOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OrganizationIDPolicyGetOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestOrganizationIDPolicyGetOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"bindings\":[{\"principals\":[{\"id\":111111111111,\"type\":\"user\"},{\"id\":1,\"type\":\"group\"},{\"id\":111111111111,\"type\":\"service-principal\"}],\"role\":{\"id\":\"identity-admin\",\"type\":\"preset\"}}]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ OrganizationIDPolicyGetOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 OrganizationIDPolicyGetOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestOrganizationIDPolicyPutOK_EncodeDecode(t *testing.T) {
	var typ OrganizationIDPolicyPutOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OrganizationIDPolicyPutOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOrganizationIDPolicyPutReq_EncodeDecode(t *testing.T) {
	var typ OrganizationIDPolicyPutReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OrganizationIDPolicyPutReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestOrganizationIDPolicyPutReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"bindings\":[{\"principals\":[{\"id\":111111111111,\"type\":\"user\"},{\"id\":1,\"type\":\"group\"},{\"id\":111111111111,\"type\":\"service-principal\"}],\"role\":{\"id\":\"identity-admin\",\"type\":\"preset\"}}]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ OrganizationIDPolicyPutReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 OrganizationIDPolicyPutReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestOrganizationIamPolicyGetOK_EncodeDecode(t *testing.T) {
	var typ OrganizationIamPolicyGetOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OrganizationIamPolicyGetOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestOrganizationIamPolicyGetOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"bindings\":[{\"principals\":[{\"id\":111111111111,\"type\":\"user\"},{\"id\":1,\"type\":\"group\"},{\"id\":111111111111,\"type\":\"service-principal\"}],\"role\":{\"id\":\"admin\",\"type\":\"preset\"}}]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ OrganizationIamPolicyGetOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 OrganizationIamPolicyGetOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestOrganizationIamPolicyPutOK_EncodeDecode(t *testing.T) {
	var typ OrganizationIamPolicyPutOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OrganizationIamPolicyPutOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOrganizationIamPolicyPutReq_EncodeDecode(t *testing.T) {
	var typ OrganizationIamPolicyPutReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OrganizationIamPolicyPutReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestOrganizationIamPolicyPutReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"bindings\":[{\"principals\":[{\"id\":111111111111,\"type\":\"user\"},{\"id\":1,\"type\":\"group\"},{\"id\":111111111111,\"type\":\"service-principal\"}],\"role\":{\"id\":\"admin\",\"type\":\"preset\"}}]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ OrganizationIamPolicyPutReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 OrganizationIamPolicyPutReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestOrganizationPutReq_EncodeDecode(t *testing.T) {
	var typ OrganizationPutReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OrganizationPutReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOrganizationServicePolicyGetOK_EncodeDecode(t *testing.T) {
	var typ OrganizationServicePolicyGetOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OrganizationServicePolicyGetOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestOrganizationServicePolicyGetOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"rules\":[{\"code\":\"example.rule.code1\",\"dry_run_spec\":{\"contents\":[{\"allow_all\":false,\"deny_all\":true,\"values\":{\"allowed_values\":[\"example1\"],\"denied_values\":[\"example2\"]}}]},\"is_active\":false,\"is_dry_run\":false,\"name\":\"Example List Rule\",\"spec\":{\"contents\":[{\"allow_all\":true,\"deny_all\":true,\"values\":{\"allowed_values\":[\"example1\"],\"denied_values\":[\"example2\"]}}]}}]}"},
		{Input: "{\"rules\":[{\"code\":\"example.rule.code1\",\"dry_run_spec\":{\"contents\":[{\"allow_all\":false,\"deny_all\":true,\"values\":{\"allowed_values\":[\"example1\"],\"denied_values\":[\"example2\"]}}]},\"is_active\":false,\"is_dry_run\":true,\"name\":\"Example List Rule\",\"spec\":{\"contents\":[{\"allow_all\":true,\"deny_all\":true,\"values\":{\"allowed_values\":[\"example1\"],\"denied_values\":[\"example2\"]}}]}}]}"},
		{Input: "{\"rules\":[{\"code\":\"example.rule.code1\",\"dry_run_spec\":{\"contents\":[{\"allow_all\":false,\"deny_all\":true,\"values\":{\"allowed_values\":[\"example1\"],\"denied_values\":[\"example2\"]}}]},\"is_active\":true,\"is_dry_run\":false,\"name\":\"Example List Rule\",\"spec\":{\"contents\":[{\"allow_all\":true,\"deny_all\":true,\"values\":{\"allowed_values\":[\"example1\"],\"denied_values\":[\"example2\"]}}]}}]}"},
		{Input: "{\"rules\":[{\"code\":\"example.rule.code1\",\"dry_run_spec\":{\"contents\":[{\"allow_all\":false,\"deny_all\":true,\"values\":{\"allowed_values\":[\"example1\"],\"denied_values\":[\"example2\"]}}]},\"is_active\":true,\"is_dry_run\":true,\"name\":\"Example List Rule\",\"spec\":{\"contents\":[{\"allow_all\":true,\"deny_all\":true,\"values\":{\"allowed_values\":[\"example1\"],\"denied_values\":[\"example2\"]}}]}}]}"},
		{Input: "{\"rules\":[{\"code\":\"example.rule.code2\",\"dry_run_spec\":{\"contents\":[{\"enforce\":true}]},\"is_active\":false,\"is_dry_run\":false,\"name\":\"Example Bool Rule\",\"spec\":{\"contents\":[{\"enforce\":true}]}}]}"},
		{Input: "{\"rules\":[{\"code\":\"example.rule.code2\",\"dry_run_spec\":{\"contents\":[{\"enforce\":true}]},\"is_active\":false,\"is_dry_run\":true,\"name\":\"Example Bool Rule\",\"spec\":{\"contents\":[{\"enforce\":true}]}}]}"},
		{Input: "{\"rules\":[{\"code\":\"example.rule.code2\",\"dry_run_spec\":{\"contents\":[{\"enforce\":true}]},\"is_active\":true,\"is_dry_run\":false,\"name\":\"Example Bool Rule\",\"spec\":{\"contents\":[{\"enforce\":true}]}}]}"},
		{Input: "{\"rules\":[{\"code\":\"example.rule.code2\",\"dry_run_spec\":{\"contents\":[{\"enforce\":true}]},\"is_active\":true,\"is_dry_run\":true,\"name\":\"Example Bool Rule\",\"spec\":{\"contents\":[{\"enforce\":true}]}}]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ OrganizationServicePolicyGetOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 OrganizationServicePolicyGetOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestOrganizationServicePolicyPutOK_EncodeDecode(t *testing.T) {
	var typ OrganizationServicePolicyPutOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OrganizationServicePolicyPutOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOrganizationServicePolicyPutReq_EncodeDecode(t *testing.T) {
	var typ OrganizationServicePolicyPutReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OrganizationServicePolicyPutReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestOrganizationServicePolicyPutReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"rules\":[{\"code\":\"example.rule.list\",\"is_active\":true,\"is_dry_run\":false,\"spec\":{\"contents\":[{\"allow_all\":false,\"deny_all\":false,\"values\":{\"allowed_values\":[\"example1\",\"example2\"]}}]}}]}"},
		{Input: "{\"rules\":[{\"code\":\"example.rule.list\",\"is_active\":true,\"is_dry_run\":false,\"spec\":{\"contents\":[{\"allow_all\":false,\"deny_all\":false,\"values\":{\"denied_values\":[\"example1\",\"example2\"]}}]}}]}"},
		{Input: "{\"rules\":[{\"code\":\"example.rule.list\",\"is_active\":true,\"is_dry_run\":false,\"spec\":{\"contents\":[{\"allow_all\":false,\"deny_all\":true,\"values\":{}}]}}]}"},
		{Input: "{\"rules\":[{\"code\":\"example.rule.list\",\"is_active\":true,\"is_dry_run\":false,\"spec\":{\"contents\":[{\"allow_all\":true,\"deny_all\":false,\"values\":{\"allowed_values\":[\"example1\",\"example2\"]}}]}},{\"code\":\"example.rule.bool\",\"is_active\":false,\"is_dry_run\":false,\"spec\":{\"contents\":[{\"enforce\":true}]}}]}"},
		{Input: "{\"rules\":[{\"code\":\"example.rule.list\",\"is_active\":true,\"is_dry_run\":false,\"spec\":{\"contents\":[{\"allow_all\":true,\"deny_all\":false,\"values\":{}}]}}]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ OrganizationServicePolicyPutReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 OrganizationServicePolicyPutReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestPasswordPolicy_EncodeDecode(t *testing.T) {
	var typ PasswordPolicy
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PasswordPolicy
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPrincipal_EncodeDecode(t *testing.T) {
	var typ Principal
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Principal
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProject_EncodeDecode(t *testing.T) {
	var typ Project
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Project
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectApiKey_EncodeDecode(t *testing.T) {
	var typ ProjectApiKey
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectApiKey
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectApiKeyWithSecret_EncodeDecode(t *testing.T) {
	var typ ProjectApiKeyWithSecret
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectApiKeyWithSecret
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectStatus_EncodeDecode(t *testing.T) {
	var typ ProjectStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestProjectStatus_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"available\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ProjectStatus

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ProjectStatus
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestProjectsGetOK_EncodeDecode(t *testing.T) {
	var typ ProjectsGetOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsGetOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsPostReq_EncodeDecode(t *testing.T) {
	var typ ProjectsPostReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsPostReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsProjectIDIamPolicyGetOK_EncodeDecode(t *testing.T) {
	var typ ProjectsProjectIDIamPolicyGetOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsProjectIDIamPolicyGetOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestProjectsProjectIDIamPolicyGetOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"bindings\":[{\"principals\":[{\"id\":111111111111,\"type\":\"user\"},{\"id\":1,\"type\":\"group\"},{\"id\":111111111111,\"type\":\"service-principal\"}],\"role\":{\"id\":\"admin\",\"type\":\"preset\"}}]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ProjectsProjectIDIamPolicyGetOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ProjectsProjectIDIamPolicyGetOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestProjectsProjectIDIamPolicyPutOK_EncodeDecode(t *testing.T) {
	var typ ProjectsProjectIDIamPolicyPutOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsProjectIDIamPolicyPutOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectsProjectIDIamPolicyPutReq_EncodeDecode(t *testing.T) {
	var typ ProjectsProjectIDIamPolicyPutReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsProjectIDIamPolicyPutReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestProjectsProjectIDIamPolicyPutReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"bindings\":[{\"principals\":[{\"id\":111111111111,\"type\":\"user\"},{\"id\":1,\"type\":\"group\"},{\"id\":111111111111,\"type\":\"service-principal\"}],\"role\":{\"id\":\"admin\",\"type\":\"preset\"}}]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ProjectsProjectIDIamPolicyPutReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ProjectsProjectIDIamPolicyPutReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestProjectsProjectIDPutReq_EncodeDecode(t *testing.T) {
	var typ ProjectsProjectIDPutReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectsProjectIDPutReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRule_EncodeDecode(t *testing.T) {
	var typ Rule
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Rule
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRuleContent_EncodeDecode(t *testing.T) {
	var typ RuleContent
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RuleContent
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRuleContentValues_EncodeDecode(t *testing.T) {
	var typ RuleContentValues
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RuleContentValues
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRuleResponse_EncodeDecode(t *testing.T) {
	var typ RuleResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RuleResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRuleSpec_EncodeDecode(t *testing.T) {
	var typ RuleSpec
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RuleSpec
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRuleTemplate_EncodeDecode(t *testing.T) {
	var typ RuleTemplate
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RuleTemplate
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSSOProfile_EncodeDecode(t *testing.T) {
	var typ SSOProfile
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SSOProfile
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSSOProfilesGetOK_EncodeDecode(t *testing.T) {
	var typ SSOProfilesGetOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SSOProfilesGetOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSSOProfilesPostReq_EncodeDecode(t *testing.T) {
	var typ SSOProfilesPostReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SSOProfilesPostReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSSOProfilesSSOProfileIDPutReq_EncodeDecode(t *testing.T) {
	var typ SSOProfilesSSOProfileIDPutReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SSOProfilesSSOProfileIDPutReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestServicePolicyRuleTemplatesGetOK_EncodeDecode(t *testing.T) {
	var typ ServicePolicyRuleTemplatesGetOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ServicePolicyRuleTemplatesGetOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestServicePolicyStatusGetOK_EncodeDecode(t *testing.T) {
	var typ ServicePolicyStatusGetOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ServicePolicyStatusGetOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestServicePrincipal_EncodeDecode(t *testing.T) {
	var typ ServicePrincipal
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ServicePrincipal
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestServicePrincipalKey_EncodeDecode(t *testing.T) {
	var typ ServicePrincipalKey
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ServicePrincipalKey
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestServicePrincipalKey_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"created_at\":\"2023-10-01T00:00:00Z\",\"expired_at\":\"2024-10-01T00:00:00Z\",\"id\":\"00000000-0000-0000-0000-000000000000\",\"key_origin\":\"user\",\"status\":\"disabled\"}"},
		{Input: "{\"created_at\":\"2023-10-01T00:00:00Z\",\"expired_at\":\"2024-10-01T00:00:00Z\",\"id\":\"00000000-0000-0000-0000-000000000000\",\"key_origin\":\"user\",\"status\":\"enabled\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ServicePrincipalKey

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ServicePrincipalKey
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestServicePrincipalKeyKeyOrigin_EncodeDecode(t *testing.T) {
	var typ ServicePrincipalKeyKeyOrigin
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ServicePrincipalKeyKeyOrigin
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestServicePrincipalKeyKeyOrigin_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"user\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ServicePrincipalKeyKeyOrigin

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ServicePrincipalKeyKeyOrigin
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestServicePrincipalKeyStatus_EncodeDecode(t *testing.T) {
	var typ ServicePrincipalKeyStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ServicePrincipalKeyStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestServicePrincipalKeyStatus_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"enabled\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ServicePrincipalKeyStatus

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ServicePrincipalKeyStatus
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestServicePrincipalOAuth2AccessToken_EncodeDecode(t *testing.T) {
	var typ ServicePrincipalOAuth2AccessToken
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ServicePrincipalOAuth2AccessToken
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestServicePrincipalsGetOK_EncodeDecode(t *testing.T) {
	var typ ServicePrincipalsGetOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ServicePrincipalsGetOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestServicePrincipalsPostReq_EncodeDecode(t *testing.T) {
	var typ ServicePrincipalsPostReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ServicePrincipalsPostReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestServicePrincipalsServicePrincipalIDKeysGetOK_EncodeDecode(t *testing.T) {
	var typ ServicePrincipalsServicePrincipalIDKeysGetOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ServicePrincipalsServicePrincipalIDKeysGetOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestServicePrincipalsServicePrincipalIDPutReq_EncodeDecode(t *testing.T) {
	var typ ServicePrincipalsServicePrincipalIDPutReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ServicePrincipalsServicePrincipalIDPutReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestServicePrincipalsServicePrincipalIDUploadKeyPostReq_EncodeDecode(t *testing.T) {
	var typ ServicePrincipalsServicePrincipalIDUploadKeyPostReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ServicePrincipalsServicePrincipalIDUploadKeyPostReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestServiceprincipalKeyPublicKey_EncodeDecode(t *testing.T) {
	var typ ServiceprincipalKeyPublicKey
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ServiceprincipalKeyPublicKey
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUser_EncodeDecode(t *testing.T) {
	var typ User
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 User
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUserMember_EncodeDecode(t *testing.T) {
	var typ UserMember
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UserMember
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUserOtp_EncodeDecode(t *testing.T) {
	var typ UserOtp
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UserOtp
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUserOtpStatus_EncodeDecode(t *testing.T) {
	var typ UserOtpStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UserOtpStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestUserOtpStatus_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"deactivated\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ UserOtpStatus

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 UserOtpStatus
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestUserSecurityKey_EncodeDecode(t *testing.T) {
	var typ UserSecurityKey
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UserSecurityKey
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestUserSecurityKey_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"aaguid\":\"00000000-0000-0000-0000-000000000000\",\"id\":1,\"last_used_at\":\"2025-08-27T11:00:00.123456+09:00\",\"name\":\"ユーザが設定した名前\",\"registered_at\":\"2025-08-27T10:00:00.123456+09:00\",\"sign_count\":1}"},
		{Input: "{\"aaguid\":\"00000000-0000-0000-0000-000000000000\",\"id\":1,\"last_used_at\":null,\"name\":\"\",\"registered_at\":\"2025-08-27T10:00:00.123456+09:00\",\"sign_count\":0}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ UserSecurityKey

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 UserSecurityKey
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestUserStatus_EncodeDecode(t *testing.T) {
	var typ UserStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UserStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestUserStatus_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"available\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ UserStatus

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 UserStatus
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestUserTrustedDevice_EncodeDecode(t *testing.T) {
	var typ UserTrustedDevice
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UserTrustedDevice
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
