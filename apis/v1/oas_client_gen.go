// Code generated by ogen, DO NOT EDIT.

package v1

import (
	"context"
	"net/url"
	"strings"

	"github.com/go-faster/errors"
	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/uri"
)

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// CompatAPIKeysApikeyIDDelete invokes DELETE /compat/api-keys/{apikey_id} operation.
	//
	// 指定したAPIキーを削除する.
	//
	// DELETE /compat/api-keys/{apikey_id}
	CompatAPIKeysApikeyIDDelete(ctx context.Context, params CompatAPIKeysApikeyIDDeleteParams) (CompatAPIKeysApikeyIDDeleteRes, error)
	// CompatAPIKeysApikeyIDGet invokes GET /compat/api-keys/{apikey_id} operation.
	//
	// 指定したAPIキーを取得する.
	//
	// GET /compat/api-keys/{apikey_id}
	CompatAPIKeysApikeyIDGet(ctx context.Context, params CompatAPIKeysApikeyIDGetParams) (CompatAPIKeysApikeyIDGetRes, error)
	// CompatAPIKeysApikeyIDPut invokes PUT /compat/api-keys/{apikey_id} operation.
	//
	// 指定したAPIキーを更新する.
	//
	// PUT /compat/api-keys/{apikey_id}
	CompatAPIKeysApikeyIDPut(ctx context.Context, request *CompatAPIKeysApikeyIDPutReq, params CompatAPIKeysApikeyIDPutParams) (CompatAPIKeysApikeyIDPutRes, error)
	// CompatAPIKeysGet invokes GET /compat/api-keys operation.
	//
	// APIキー一覧を取得する.
	//
	// GET /compat/api-keys
	CompatAPIKeysGet(ctx context.Context, params CompatAPIKeysGetParams) (CompatAPIKeysGetRes, error)
	// CompatAPIKeysPost invokes POST /compat/api-keys operation.
	//
	// APIキーを作成する.
	//
	// POST /compat/api-keys
	CompatAPIKeysPost(ctx context.Context, request *CompatAPIKeysPostReq) (CompatAPIKeysPostRes, error)
	// CompatUsersGet invokes GET /compat/users operation.
	//
	// ユーザ一覧を取得する.
	//
	// GET /compat/users
	CompatUsersGet(ctx context.Context, params CompatUsersGetParams) (CompatUsersGetRes, error)
	// CompatUsersPost invokes POST /compat/users operation.
	//
	// ユーザを作成する.
	//
	// POST /compat/users
	CompatUsersPost(ctx context.Context, request *CompatUsersPostReq) (CompatUsersPostRes, error)
	// CompatUsersUserIDActivateOtpPost invokes POST /compat/users/{user_id}/activate-otp operation.
	//
	// 指定したユーザのワンタイムパスワード認証の有効化を開始し、シークレットキーを取得します。.
	//
	// POST /compat/users/{user_id}/activate-otp
	CompatUsersUserIDActivateOtpPost(ctx context.Context, params CompatUsersUserIDActivateOtpPostParams) (CompatUsersUserIDActivateOtpPostRes, error)
	// CompatUsersUserIDClearTrustedDevicesPost invokes POST /compat/users/{user_id}/clear-trusted-devices operation.
	//
	// ユーザの全信頼済みデバイスを削除する.
	//
	// POST /compat/users/{user_id}/clear-trusted-devices
	CompatUsersUserIDClearTrustedDevicesPost(ctx context.Context, params CompatUsersUserIDClearTrustedDevicesPostParams) (CompatUsersUserIDClearTrustedDevicesPostRes, error)
	// CompatUsersUserIDDeactivateOtpPost invokes POST /compat/users/{user_id}/deactivate-otp operation.
	//
	// 指定したユーザのワンタイムパスワード認証を無効化します。.
	//
	// POST /compat/users/{user_id}/deactivate-otp
	CompatUsersUserIDDeactivateOtpPost(ctx context.Context, params CompatUsersUserIDDeactivateOtpPostParams) (CompatUsersUserIDDeactivateOtpPostRes, error)
	// CompatUsersUserIDDelete invokes DELETE /compat/users/{user_id} operation.
	//
	// 指定したユーザを削除する.
	//
	// DELETE /compat/users/{user_id}
	CompatUsersUserIDDelete(ctx context.Context, params CompatUsersUserIDDeleteParams) (CompatUsersUserIDDeleteRes, error)
	// CompatUsersUserIDGet invokes GET /compat/users/{user_id} operation.
	//
	// 指定したユーザを取得する.
	//
	// GET /compat/users/{user_id}
	CompatUsersUserIDGet(ctx context.Context, params CompatUsersUserIDGetParams) (CompatUsersUserIDGetRes, error)
	// CompatUsersUserIDPut invokes PUT /compat/users/{user_id} operation.
	//
	// 指定したユーザを更新する.
	//
	// PUT /compat/users/{user_id}
	CompatUsersUserIDPut(ctx context.Context, request *CompatUsersUserIDPutReq, params CompatUsersUserIDPutParams) (CompatUsersUserIDPutRes, error)
	// CompatUsersUserIDRecoveryCodePost invokes POST /compat/users/{user_id}/recovery-code operation.
	//
	// 指定したユーザの2要素認証リカバリコードを発行します。再実行するとリカバリコードが上書きされます。.
	//
	// POST /compat/users/{user_id}/recovery-code
	CompatUsersUserIDRecoveryCodePost(ctx context.Context, params CompatUsersUserIDRecoveryCodePostParams) (CompatUsersUserIDRecoveryCodePostRes, error)
	// CompatUsersUserIDRegisterEmailPost invokes POST /compat/users/{user_id}/register-email operation.
	//
	// ユーザにメールアドレスを登録する.
	//
	// POST /compat/users/{user_id}/register-email
	CompatUsersUserIDRegisterEmailPost(ctx context.Context, request *CompatUsersUserIDRegisterEmailPostReq, params CompatUsersUserIDRegisterEmailPostParams) (CompatUsersUserIDRegisterEmailPostRes, error)
	// CompatUsersUserIDSecurityKeysGet invokes GET /compat/users/{user_id}/security-keys operation.
	//
	// ユーザのセキュリティキー一覧を取得する.
	//
	// GET /compat/users/{user_id}/security-keys
	CompatUsersUserIDSecurityKeysGet(ctx context.Context, params CompatUsersUserIDSecurityKeysGetParams) (CompatUsersUserIDSecurityKeysGetRes, error)
	// CompatUsersUserIDSecurityKeysSecurityKeyIDDelete invokes DELETE /compat/users/{user_id}/security-keys/{security_key_id} operation.
	//
	// ユーザのセキュリティキーを削除する.
	//
	// DELETE /compat/users/{user_id}/security-keys/{security_key_id}
	CompatUsersUserIDSecurityKeysSecurityKeyIDDelete(ctx context.Context, params CompatUsersUserIDSecurityKeysSecurityKeyIDDeleteParams) (CompatUsersUserIDSecurityKeysSecurityKeyIDDeleteRes, error)
	// CompatUsersUserIDSecurityKeysSecurityKeyIDGet invokes GET /compat/users/{user_id}/security-keys/{security_key_id} operation.
	//
	// ユーザのセキュリティキーを取得する.
	//
	// GET /compat/users/{user_id}/security-keys/{security_key_id}
	CompatUsersUserIDSecurityKeysSecurityKeyIDGet(ctx context.Context, params CompatUsersUserIDSecurityKeysSecurityKeyIDGetParams) (CompatUsersUserIDSecurityKeysSecurityKeyIDGetRes, error)
	// CompatUsersUserIDSecurityKeysSecurityKeyIDPut invokes PUT /compat/users/{user_id}/security-keys/{security_key_id} operation.
	//
	// ユーザのセキュリティキーを更新する.
	//
	// PUT /compat/users/{user_id}/security-keys/{security_key_id}
	CompatUsersUserIDSecurityKeysSecurityKeyIDPut(ctx context.Context, request OptCompatUsersUserIDSecurityKeysSecurityKeyIDPutReq, params CompatUsersUserIDSecurityKeysSecurityKeyIDPutParams) (CompatUsersUserIDSecurityKeysSecurityKeyIDPutRes, error)
	// CompatUsersUserIDStartSecurityKeyRegistrationPost invokes POST /compat/users/{user_id}/start-security-key-registration operation.
	//
	// 指定したユーザのセキュリティキー登録を開始します。現時点でのセキュリティキーの最大登録数は1つです。
	// WebAuthnのPublicKeyCredentialCreationOptions生成を行います。.
	//
	// POST /compat/users/{user_id}/start-security-key-registration
	CompatUsersUserIDStartSecurityKeyRegistrationPost(ctx context.Context, params CompatUsersUserIDStartSecurityKeyRegistrationPostParams) (CompatUsersUserIDStartSecurityKeyRegistrationPostRes, error)
	// CompatUsersUserIDTrustedDevicesGet invokes GET /compat/users/{user_id}/trusted-devices operation.
	//
	// ユーザの信頼済みデバイス一覧を取得する.
	//
	// GET /compat/users/{user_id}/trusted-devices
	CompatUsersUserIDTrustedDevicesGet(ctx context.Context, params CompatUsersUserIDTrustedDevicesGetParams) (CompatUsersUserIDTrustedDevicesGetRes, error)
	// CompatUsersUserIDTrustedDevicesTrustedDeviceIDDelete invokes DELETE /compat/users/{user_id}/trusted-devices/{trusted_device_id} operation.
	//
	// ユーザの信頼済みデバイスを削除する.
	//
	// DELETE /compat/users/{user_id}/trusted-devices/{trusted_device_id}
	CompatUsersUserIDTrustedDevicesTrustedDeviceIDDelete(ctx context.Context, params CompatUsersUserIDTrustedDevicesTrustedDeviceIDDeleteParams) (CompatUsersUserIDTrustedDevicesTrustedDeviceIDDeleteRes, error)
	// CompatUsersUserIDUnregisterEmailPost invokes POST /compat/users/{user_id}/unregister-email operation.
	//
	// ユーザのメールアドレスを削除する.
	//
	// POST /compat/users/{user_id}/unregister-email
	CompatUsersUserIDUnregisterEmailPost(ctx context.Context, params CompatUsersUserIDUnregisterEmailPostParams) (CompatUsersUserIDUnregisterEmailPostRes, error)
	// CompatUsersUserIDValidateSecurityKeyRegistrationPost invokes POST /compat/users/{user_id}/validate-security-key-registration operation.
	//
	// 指定したユーザのセキュリティキー登録を完了します。
	// ブラウザの `navigator.credentials.create()` で生成された[認証情報](https://www.w3.
	// org/TR/webauthn-2/#publickeycredential)を受け取って検証します。.
	//
	// POST /compat/users/{user_id}/validate-security-key-registration
	CompatUsersUserIDValidateSecurityKeyRegistrationPost(ctx context.Context, request *CompatUsersUserIDValidateSecurityKeyRegistrationPostReq, params CompatUsersUserIDValidateSecurityKeyRegistrationPostParams) (CompatUsersUserIDValidateSecurityKeyRegistrationPostRes, error)
	// DisableServicePolicyPost invokes POST /disable-service-policy operation.
	//
	// サービスポリシーを無効化する.
	//
	// POST /disable-service-policy
	DisableServicePolicyPost(ctx context.Context) (DisableServicePolicyPostRes, error)
	// EnableServicePolicyPost invokes POST /enable-service-policy operation.
	//
	// サービスポリシーを有効化する.
	//
	// POST /enable-service-policy
	EnableServicePolicyPost(ctx context.Context) (EnableServicePolicyPostRes, error)
	// FoldersFolderIDDelete invokes DELETE /folders/{folder_id} operation.
	//
	// フォルダを削除する.
	//
	// DELETE /folders/{folder_id}
	FoldersFolderIDDelete(ctx context.Context, params FoldersFolderIDDeleteParams) (FoldersFolderIDDeleteRes, error)
	// FoldersFolderIDGet invokes GET /folders/{folder_id} operation.
	//
	// 特定のフォルダの情報を取得する.
	//
	// GET /folders/{folder_id}
	FoldersFolderIDGet(ctx context.Context, params FoldersFolderIDGetParams) (FoldersFolderIDGetRes, error)
	// FoldersFolderIDIamPolicyGet invokes GET /folders/{folder_id}/iam-policy operation.
	//
	// フォルダIAMポリシーを取得する.
	//
	// GET /folders/{folder_id}/iam-policy
	FoldersFolderIDIamPolicyGet(ctx context.Context, params FoldersFolderIDIamPolicyGetParams) (FoldersFolderIDIamPolicyGetRes, error)
	// FoldersFolderIDIamPolicyPut invokes PUT /folders/{folder_id}/iam-policy operation.
	//
	// フォルダIAMポリシーを更新する.
	//
	// PUT /folders/{folder_id}/iam-policy
	FoldersFolderIDIamPolicyPut(ctx context.Context, request *FoldersFolderIDIamPolicyPutReq, params FoldersFolderIDIamPolicyPutParams) (FoldersFolderIDIamPolicyPutRes, error)
	// FoldersFolderIDPut invokes PUT /folders/{folder_id} operation.
	//
	// 特定のフォルダの情報を更新する.
	//
	// PUT /folders/{folder_id}
	FoldersFolderIDPut(ctx context.Context, request *FoldersFolderIDPutReq, params FoldersFolderIDPutParams) (FoldersFolderIDPutRes, error)
	// FoldersGet invokes GET /folders operation.
	//
	// フォルダ一覧を取得する.
	//
	// GET /folders
	FoldersGet(ctx context.Context, params FoldersGetParams) (FoldersGetRes, error)
	// FoldersPost invokes POST /folders operation.
	//
	// フォルダを作成する.
	//
	// POST /folders
	FoldersPost(ctx context.Context, request *FoldersPostReq) (FoldersPostRes, error)
	// GroupsGet invokes GET /groups operation.
	//
	// グループ一覧を取得する.
	//
	// GET /groups
	GroupsGet(ctx context.Context, params GroupsGetParams) (GroupsGetRes, error)
	// GroupsGroupIDDelete invokes DELETE /groups/{group_id} operation.
	//
	// 指定したグループを削除する.
	//
	// DELETE /groups/{group_id}
	GroupsGroupIDDelete(ctx context.Context, params GroupsGroupIDDeleteParams) (GroupsGroupIDDeleteRes, error)
	// GroupsGroupIDGet invokes GET /groups/{group_id} operation.
	//
	// 指定したグループを取得する.
	//
	// GET /groups/{group_id}
	GroupsGroupIDGet(ctx context.Context, params GroupsGroupIDGetParams) (GroupsGroupIDGetRes, error)
	// GroupsGroupIDMembershipsGet invokes GET /groups/{group_id}/memberships operation.
	//
	// グループの所属情報を取得する.
	//
	// GET /groups/{group_id}/memberships
	GroupsGroupIDMembershipsGet(ctx context.Context, params GroupsGroupIDMembershipsGetParams) (GroupsGroupIDMembershipsGetRes, error)
	// GroupsGroupIDMembershipsPut invokes PUT /groups/{group_id}/memberships operation.
	//
	// グループの所属情報を更新する.
	//
	// PUT /groups/{group_id}/memberships
	GroupsGroupIDMembershipsPut(ctx context.Context, request *GroupsGroupIDMembershipsPutReq, params GroupsGroupIDMembershipsPutParams) (GroupsGroupIDMembershipsPutRes, error)
	// GroupsGroupIDPut invokes PUT /groups/{group_id} operation.
	//
	// 指定したグループを更新する.
	//
	// PUT /groups/{group_id}
	GroupsGroupIDPut(ctx context.Context, request *GroupsGroupIDPutReq, params GroupsGroupIDPutParams) (GroupsGroupIDPutRes, error)
	// GroupsPost invokes POST /groups operation.
	//
	// グループを作成する.
	//
	// POST /groups
	GroupsPost(ctx context.Context, request *GroupsPostReq) (GroupsPostRes, error)
	// IDRolesGet invokes GET /id-roles operation.
	//
	// IDロール一覧を取得する.
	//
	// GET /id-roles
	IDRolesGet(ctx context.Context, params IDRolesGetParams) (IDRolesGetRes, error)
	// IDRolesIDRoleIDGet invokes GET /id-roles/{id_role_id} operation.
	//
	// 指定したIDロールを取得する.
	//
	// GET /id-roles/{id_role_id}
	IDRolesIDRoleIDGet(ctx context.Context, params IDRolesIDRoleIDGetParams) (IDRolesIDRoleIDGetRes, error)
	// IamRolesGet invokes GET /iam-roles operation.
	//
	// IAMロール一覧を取得する.
	//
	// GET /iam-roles
	IamRolesGet(ctx context.Context, params IamRolesGetParams) (IamRolesGetRes, error)
	// IamRolesIamRoleIDGet invokes GET /iam-roles/{iam_role_id} operation.
	//
	// 指定したIAMロールを取得する.
	//
	// GET /iam-roles/{iam_role_id}
	IamRolesIamRoleIDGet(ctx context.Context, params IamRolesIamRoleIDGetParams) (IamRolesIamRoleIDGetRes, error)
	// MoveFoldersPost invokes POST /move-folders operation.
	//
	// フォルダを移動する.
	//
	// POST /move-folders
	MoveFoldersPost(ctx context.Context, request *MoveFolders) (MoveFoldersPostRes, error)
	// MoveProjectsPost invokes POST /move-projects operation.
	//
	// プロジェクトを一括で移動する.
	//
	// POST /move-projects
	MoveProjectsPost(ctx context.Context, request *MoveProjects) (MoveProjectsPostRes, error)
	// OrganizationAuthConditionsGet invokes GET /organization-auth-conditions operation.
	//
	// 組織の認証条件を取得する.
	//
	// GET /organization-auth-conditions
	OrganizationAuthConditionsGet(ctx context.Context) (OrganizationAuthConditionsGetRes, error)
	// OrganizationAuthConditionsPut invokes PUT /organization-auth-conditions operation.
	//
	// 組織の認証条件を更新する.
	//
	// PUT /organization-auth-conditions
	OrganizationAuthConditionsPut(ctx context.Context, request *AuthConditions) (OrganizationAuthConditionsPutRes, error)
	// OrganizationGet invokes GET /organization operation.
	//
	// 組織を取得する.
	//
	// GET /organization
	OrganizationGet(ctx context.Context) (OrganizationGetRes, error)
	// OrganizationIDPolicyGet invokes GET /organization-id-policy operation.
	//
	// 組織IDポリシーを取得する.
	//
	// GET /organization-id-policy
	OrganizationIDPolicyGet(ctx context.Context) (OrganizationIDPolicyGetRes, error)
	// OrganizationIDPolicyPut invokes PUT /organization-id-policy operation.
	//
	// 組織IDポリシーを更新する.
	//
	// PUT /organization-id-policy
	OrganizationIDPolicyPut(ctx context.Context, request *OrganizationIDPolicyPutReq) (OrganizationIDPolicyPutRes, error)
	// OrganizationIamPolicyGet invokes GET /organization-iam-policy operation.
	//
	// 組織IAMポリシーを取得する.
	//
	// GET /organization-iam-policy
	OrganizationIamPolicyGet(ctx context.Context) (OrganizationIamPolicyGetRes, error)
	// OrganizationIamPolicyPut invokes PUT /organization-iam-policy operation.
	//
	// 組織IAMポリシーを更新する.
	//
	// PUT /organization-iam-policy
	OrganizationIamPolicyPut(ctx context.Context, request *OrganizationIamPolicyPutReq) (OrganizationIamPolicyPutRes, error)
	// OrganizationPasswordPolicyGet invokes GET /organization-password-policy operation.
	//
	// 組織のパスワードポリシーを取得する.
	//
	// GET /organization-password-policy
	OrganizationPasswordPolicyGet(ctx context.Context) (OrganizationPasswordPolicyGetRes, error)
	// OrganizationPasswordPolicyPut invokes PUT /organization-password-policy operation.
	//
	// 組織のパスワードポリシーを更新する.
	//
	// PUT /organization-password-policy
	OrganizationPasswordPolicyPut(ctx context.Context) (OrganizationPasswordPolicyPutRes, error)
	// OrganizationPut invokes PUT /organization operation.
	//
	// 組織を更新する.
	//
	// PUT /organization
	OrganizationPut(ctx context.Context, request *OrganizationPutReq) (OrganizationPutRes, error)
	// OrganizationServicePolicyGet invokes GET /organization-service-policy operation.
	//
	// 組織のサービスポリシーを構成するルールを取得する.
	//
	// GET /organization-service-policy
	OrganizationServicePolicyGet(ctx context.Context, params OrganizationServicePolicyGetParams) (OrganizationServicePolicyGetRes, error)
	// OrganizationServicePolicyPut invokes PUT /organization-service-policy operation.
	//
	// 組織のサービスポリシーを構成するルールの設定値を更新するエンドポイント。設定を更新するルールをリクエストボディで指定する.
	//
	// PUT /organization-service-policy
	OrganizationServicePolicyPut(ctx context.Context, request *OrganizationServicePolicyPutReq) (OrganizationServicePolicyPutRes, error)
	// ProjectsGet invokes GET /projects operation.
	//
	// プロジェクト一覧を取得する.
	//
	// GET /projects
	ProjectsGet(ctx context.Context, params ProjectsGetParams) (ProjectsGetRes, error)
	// ProjectsPost invokes POST /projects operation.
	//
	// プロジェクトを作成する.
	//
	// POST /projects
	ProjectsPost(ctx context.Context, request *ProjectsPostReq) (ProjectsPostRes, error)
	// ProjectsProjectIDDelete invokes DELETE /projects/{project_id} operation.
	//
	// 指定したプロジェクトを削除する.
	//
	// DELETE /projects/{project_id}
	ProjectsProjectIDDelete(ctx context.Context, params ProjectsProjectIDDeleteParams) (ProjectsProjectIDDeleteRes, error)
	// ProjectsProjectIDGet invokes GET /projects/{project_id} operation.
	//
	// 指定したプロジェクトを取得する.
	//
	// GET /projects/{project_id}
	ProjectsProjectIDGet(ctx context.Context, params ProjectsProjectIDGetParams) (ProjectsProjectIDGetRes, error)
	// ProjectsProjectIDIamPolicyGet invokes GET /projects/{project_id}/iam-policy operation.
	//
	// プロジェクトIAMポリシーを取得する.
	//
	// GET /projects/{project_id}/iam-policy
	ProjectsProjectIDIamPolicyGet(ctx context.Context, params ProjectsProjectIDIamPolicyGetParams) (ProjectsProjectIDIamPolicyGetRes, error)
	// ProjectsProjectIDIamPolicyPut invokes PUT /projects/{project_id}/iam-policy operation.
	//
	// プロジェクトIAMポリシーを更新する.
	//
	// PUT /projects/{project_id}/iam-policy
	ProjectsProjectIDIamPolicyPut(ctx context.Context, request *ProjectsProjectIDIamPolicyPutReq, params ProjectsProjectIDIamPolicyPutParams) (ProjectsProjectIDIamPolicyPutRes, error)
	// ProjectsProjectIDPut invokes PUT /projects/{project_id} operation.
	//
	// 指定したプロジェクトを更新する.
	//
	// PUT /projects/{project_id}
	ProjectsProjectIDPut(ctx context.Context, request *ProjectsProjectIDPutReq, params ProjectsProjectIDPutParams) (ProjectsProjectIDPutRes, error)
	// SSOProfilesGet invokes GET /sso-profiles operation.
	//
	// SSOプロファイル一覧を取得する.
	//
	// GET /sso-profiles
	SSOProfilesGet(ctx context.Context, params SSOProfilesGetParams) (SSOProfilesGetRes, error)
	// SSOProfilesPost invokes POST /sso-profiles operation.
	//
	// SSOプロファイルを作成する.
	//
	// POST /sso-profiles
	SSOProfilesPost(ctx context.Context, request *SSOProfilesPostReq) (SSOProfilesPostRes, error)
	// SSOProfilesSSOProfileIDAssignPost invokes POST /sso-profiles/{sso_profile_id}/assign operation.
	//
	// 割当を行うと会員配下のクラウドユーザすべてで該当SSOプロファイルが有効になります。.
	//
	// POST /sso-profiles/{sso_profile_id}/assign
	SSOProfilesSSOProfileIDAssignPost(ctx context.Context, params SSOProfilesSSOProfileIDAssignPostParams) (SSOProfilesSSOProfileIDAssignPostRes, error)
	// SSOProfilesSSOProfileIDDelete invokes DELETE /sso-profiles/{sso_profile_id} operation.
	//
	// 指定したSSOプロファイルを削除する.
	//
	// DELETE /sso-profiles/{sso_profile_id}
	SSOProfilesSSOProfileIDDelete(ctx context.Context, params SSOProfilesSSOProfileIDDeleteParams) (SSOProfilesSSOProfileIDDeleteRes, error)
	// SSOProfilesSSOProfileIDGet invokes GET /sso-profiles/{sso_profile_id} operation.
	//
	// 指定したSSOプロファイルを取得する.
	//
	// GET /sso-profiles/{sso_profile_id}
	SSOProfilesSSOProfileIDGet(ctx context.Context, params SSOProfilesSSOProfileIDGetParams) (SSOProfilesSSOProfileIDGetRes, error)
	// SSOProfilesSSOProfileIDPut invokes PUT /sso-profiles/{sso_profile_id} operation.
	//
	// 指定したSSOプロファイルを更新する.
	//
	// PUT /sso-profiles/{sso_profile_id}
	SSOProfilesSSOProfileIDPut(ctx context.Context, request *SSOProfilesSSOProfileIDPutReq, params SSOProfilesSSOProfileIDPutParams) (SSOProfilesSSOProfileIDPutRes, error)
	// SSOProfilesSSOProfileIDUnassignPost invokes POST /sso-profiles/{sso_profile_id}/unassign operation.
	//
	// 指定したSSOプロファイルの割り当てを外す.
	//
	// POST /sso-profiles/{sso_profile_id}/unassign
	SSOProfilesSSOProfileIDUnassignPost(ctx context.Context, params SSOProfilesSSOProfileIDUnassignPostParams) (SSOProfilesSSOProfileIDUnassignPostRes, error)
	// ServicePolicyRuleTemplatesGet invokes GET /service-policy-rule-templates operation.
	//
	// ルールテンプレートの一覧を取得する.
	//
	// GET /service-policy-rule-templates
	ServicePolicyRuleTemplatesGet(ctx context.Context, params ServicePolicyRuleTemplatesGetParams) (ServicePolicyRuleTemplatesGetRes, error)
	// ServicePolicyStatusGet invokes GET /service-policy-status operation.
	//
	// サービスポリシーの有効状態を取得する.
	//
	// GET /service-policy-status
	ServicePolicyStatusGet(ctx context.Context) (ServicePolicyStatusGetRes, error)
	// ServicePrincipalsGet invokes GET /service-principals operation.
	//
	// サービスプリンシパル一覧を取得する.
	//
	// GET /service-principals
	ServicePrincipalsGet(ctx context.Context, params ServicePrincipalsGetParams) (ServicePrincipalsGetRes, error)
	// ServicePrincipalsOAuth2TokenPost invokes POST /service-principals/oauth2/token operation.
	//
	// 登録済みサービスプリンシパルキーの秘密鍵を使い、以下のようなJWTを署名してください。
	// #### JWTのヘッダー
	// ```json
	// {
	// "alg": "RS256",
	// "kid": "$SERVICE_PRINCIPAL_KEY_KID",
	// "typ": "JWT"
	// }
	// ```
	// ### JWTのペイロード
	// ```json
	// {
	// "aud": "https://secure.sakura.ad.jp/cloud/api/iam/1.0/service-principals/oauth2/token",
	// "exp": 現在のUnix time + 5分,
	// "iat": 現在のUnix time,
	// "iss": "$SERVICE_PRINCIPAL_RESOURCE_ID",
	// "sub": "$SERVICE_PRINCIPAL_RESOURCE_ID"
	// }
	// ```.
	//
	// POST /service-principals/oauth2/token
	ServicePrincipalsOAuth2TokenPost(ctx context.Context, request *ServicePrincipalJWTGrantRequest) (ServicePrincipalsOAuth2TokenPostRes, error)
	// ServicePrincipalsPost invokes POST /service-principals operation.
	//
	// サービスプリンシパルを作成する.
	//
	// POST /service-principals
	ServicePrincipalsPost(ctx context.Context, request *ServicePrincipalsPostReq) (ServicePrincipalsPostRes, error)
	// ServicePrincipalsServicePrincipalIDDelete invokes DELETE /service-principals/{service_principal_id} operation.
	//
	// 指定したサービスプリンシパルを削除する.
	//
	// DELETE /service-principals/{service_principal_id}
	ServicePrincipalsServicePrincipalIDDelete(ctx context.Context, params ServicePrincipalsServicePrincipalIDDeleteParams) (ServicePrincipalsServicePrincipalIDDeleteRes, error)
	// ServicePrincipalsServicePrincipalIDGet invokes GET /service-principals/{service_principal_id} operation.
	//
	// 指定したサービスプリンシパルを取得する.
	//
	// GET /service-principals/{service_principal_id}
	ServicePrincipalsServicePrincipalIDGet(ctx context.Context, params ServicePrincipalsServicePrincipalIDGetParams) (ServicePrincipalsServicePrincipalIDGetRes, error)
	// ServicePrincipalsServicePrincipalIDKeysGet invokes GET /service-principals/{service_principal_id}/keys operation.
	//
	// GET /service-principals/{service_principal_id}/keys
	ServicePrincipalsServicePrincipalIDKeysGet(ctx context.Context, params ServicePrincipalsServicePrincipalIDKeysGetParams) (ServicePrincipalsServicePrincipalIDKeysGetRes, error)
	// ServicePrincipalsServicePrincipalIDKeysServicePrincipalKeyIDDelete invokes DELETE /service-principals/{service_principal_id}/keys/{service_principal_key_id} operation.
	//
	// 指定したサービスプリンシパルキーを削除する.
	//
	// DELETE /service-principals/{service_principal_id}/keys/{service_principal_key_id}
	ServicePrincipalsServicePrincipalIDKeysServicePrincipalKeyIDDelete(ctx context.Context, params ServicePrincipalsServicePrincipalIDKeysServicePrincipalKeyIDDeleteParams) (ServicePrincipalsServicePrincipalIDKeysServicePrincipalKeyIDDeleteRes, error)
	// ServicePrincipalsServicePrincipalIDKeysServicePrincipalKeyIDDisablePost invokes POST /service-principals/{service_principal_id}/keys/{service_principal_key_id}/disable operation.
	//
	// 指定したサービスプリンシパルキーを無効化する.
	//
	// POST /service-principals/{service_principal_id}/keys/{service_principal_key_id}/disable
	ServicePrincipalsServicePrincipalIDKeysServicePrincipalKeyIDDisablePost(ctx context.Context, params ServicePrincipalsServicePrincipalIDKeysServicePrincipalKeyIDDisablePostParams) (ServicePrincipalsServicePrincipalIDKeysServicePrincipalKeyIDDisablePostRes, error)
	// ServicePrincipalsServicePrincipalIDKeysServicePrincipalKeyIDEnablePost invokes POST /service-principals/{service_principal_id}/keys/{service_principal_key_id}/enable operation.
	//
	// 指定したサービスプリンシパルキーを有効化する.
	//
	// POST /service-principals/{service_principal_id}/keys/{service_principal_key_id}/enable
	ServicePrincipalsServicePrincipalIDKeysServicePrincipalKeyIDEnablePost(ctx context.Context, params ServicePrincipalsServicePrincipalIDKeysServicePrincipalKeyIDEnablePostParams) (ServicePrincipalsServicePrincipalIDKeysServicePrincipalKeyIDEnablePostRes, error)
	// ServicePrincipalsServicePrincipalIDPut invokes PUT /service-principals/{service_principal_id} operation.
	//
	// 指定したサービスプリンシパルを更新する.
	//
	// PUT /service-principals/{service_principal_id}
	ServicePrincipalsServicePrincipalIDPut(ctx context.Context, request *ServicePrincipalsServicePrincipalIDPutReq, params ServicePrincipalsServicePrincipalIDPutParams) (ServicePrincipalsServicePrincipalIDPutRes, error)
	// ServicePrincipalsServicePrincipalIDUploadKeyPost invokes POST /service-principals/{service_principal_id}/upload-key operation.
	//
	// ユーザ生成の鍵をサービスプリンシパルキーとして登録する.
	//
	// POST /service-principals/{service_principal_id}/upload-key
	ServicePrincipalsServicePrincipalIDUploadKeyPost(ctx context.Context, request OptServicePrincipalsServicePrincipalIDUploadKeyPostReq, params ServicePrincipalsServicePrincipalIDUploadKeyPostParams) (ServicePrincipalsServicePrincipalIDUploadKeyPostRes, error)
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	sec       SecuritySource
	baseClient
}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, sec SecuritySource, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		sec:        sec,
		baseClient: c,
	}, nil
}

type serverURLKey struct{}

// WithServerURL sets context key to override server URL.
func WithServerURL(ctx context.Context, u *url.URL) context.Context {
	return context.WithValue(ctx, serverURLKey{}, u)
}

func (c *Client) requestURL(ctx context.Context) *url.URL {
	u, ok := ctx.Value(serverURLKey{}).(*url.URL)
	if !ok {
		return c.serverURL
	}
	return u
}

// CompatAPIKeysApikeyIDDelete invokes DELETE /compat/api-keys/{apikey_id} operation.
//
// 指定したAPIキーを削除する.
//
// DELETE /compat/api-keys/{apikey_id}
func (c *Client) CompatAPIKeysApikeyIDDelete(ctx context.Context, params CompatAPIKeysApikeyIDDeleteParams) (CompatAPIKeysApikeyIDDeleteRes, error) {
	res, err := c.sendCompatAPIKeysApikeyIDDelete(ctx, params)
	return res, err
}

func (c *Client) sendCompatAPIKeysApikeyIDDelete(ctx context.Context, params CompatAPIKeysApikeyIDDeleteParams) (res CompatAPIKeysApikeyIDDeleteRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/compat/api-keys/"
	{
		// Encode "apikey_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "apikey_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ApikeyID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, CompatAPIKeysApikeyIDDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCompatAPIKeysApikeyIDDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CompatAPIKeysApikeyIDGet invokes GET /compat/api-keys/{apikey_id} operation.
//
// 指定したAPIキーを取得する.
//
// GET /compat/api-keys/{apikey_id}
func (c *Client) CompatAPIKeysApikeyIDGet(ctx context.Context, params CompatAPIKeysApikeyIDGetParams) (CompatAPIKeysApikeyIDGetRes, error) {
	res, err := c.sendCompatAPIKeysApikeyIDGet(ctx, params)
	return res, err
}

func (c *Client) sendCompatAPIKeysApikeyIDGet(ctx context.Context, params CompatAPIKeysApikeyIDGetParams) (res CompatAPIKeysApikeyIDGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/compat/api-keys/"
	{
		// Encode "apikey_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "apikey_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ApikeyID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, CompatAPIKeysApikeyIDGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCompatAPIKeysApikeyIDGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CompatAPIKeysApikeyIDPut invokes PUT /compat/api-keys/{apikey_id} operation.
//
// 指定したAPIキーを更新する.
//
// PUT /compat/api-keys/{apikey_id}
func (c *Client) CompatAPIKeysApikeyIDPut(ctx context.Context, request *CompatAPIKeysApikeyIDPutReq, params CompatAPIKeysApikeyIDPutParams) (CompatAPIKeysApikeyIDPutRes, error) {
	res, err := c.sendCompatAPIKeysApikeyIDPut(ctx, request, params)
	return res, err
}

func (c *Client) sendCompatAPIKeysApikeyIDPut(ctx context.Context, request *CompatAPIKeysApikeyIDPutReq, params CompatAPIKeysApikeyIDPutParams) (res CompatAPIKeysApikeyIDPutRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/compat/api-keys/"
	{
		// Encode "apikey_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "apikey_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ApikeyID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCompatAPIKeysApikeyIDPutRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, CompatAPIKeysApikeyIDPutOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCompatAPIKeysApikeyIDPutResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CompatAPIKeysGet invokes GET /compat/api-keys operation.
//
// APIキー一覧を取得する.
//
// GET /compat/api-keys
func (c *Client) CompatAPIKeysGet(ctx context.Context, params CompatAPIKeysGetParams) (CompatAPIKeysGetRes, error) {
	res, err := c.sendCompatAPIKeysGet(ctx, params)
	return res, err
}

func (c *Client) sendCompatAPIKeysGet(ctx context.Context, params CompatAPIKeysGetParams) (res CompatAPIKeysGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/compat/api-keys"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "ordering" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "ordering",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Ordering.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, CompatAPIKeysGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCompatAPIKeysGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CompatAPIKeysPost invokes POST /compat/api-keys operation.
//
// APIキーを作成する.
//
// POST /compat/api-keys
func (c *Client) CompatAPIKeysPost(ctx context.Context, request *CompatAPIKeysPostReq) (CompatAPIKeysPostRes, error) {
	res, err := c.sendCompatAPIKeysPost(ctx, request)
	return res, err
}

func (c *Client) sendCompatAPIKeysPost(ctx context.Context, request *CompatAPIKeysPostReq) (res CompatAPIKeysPostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/compat/api-keys"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCompatAPIKeysPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, CompatAPIKeysPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCompatAPIKeysPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CompatUsersGet invokes GET /compat/users operation.
//
// ユーザ一覧を取得する.
//
// GET /compat/users
func (c *Client) CompatUsersGet(ctx context.Context, params CompatUsersGetParams) (CompatUsersGetRes, error) {
	res, err := c.sendCompatUsersGet(ctx, params)
	return res, err
}

func (c *Client) sendCompatUsersGet(ctx context.Context, params CompatUsersGetParams) (res CompatUsersGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/compat/users"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "ordering" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "ordering",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Ordering.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, CompatUsersGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCompatUsersGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CompatUsersPost invokes POST /compat/users operation.
//
// ユーザを作成する.
//
// POST /compat/users
func (c *Client) CompatUsersPost(ctx context.Context, request *CompatUsersPostReq) (CompatUsersPostRes, error) {
	res, err := c.sendCompatUsersPost(ctx, request)
	return res, err
}

func (c *Client) sendCompatUsersPost(ctx context.Context, request *CompatUsersPostReq) (res CompatUsersPostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/compat/users"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCompatUsersPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, CompatUsersPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCompatUsersPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CompatUsersUserIDActivateOtpPost invokes POST /compat/users/{user_id}/activate-otp operation.
//
// 指定したユーザのワンタイムパスワード認証の有効化を開始し、シークレットキーを取得します。.
//
// POST /compat/users/{user_id}/activate-otp
func (c *Client) CompatUsersUserIDActivateOtpPost(ctx context.Context, params CompatUsersUserIDActivateOtpPostParams) (CompatUsersUserIDActivateOtpPostRes, error) {
	res, err := c.sendCompatUsersUserIDActivateOtpPost(ctx, params)
	return res, err
}

func (c *Client) sendCompatUsersUserIDActivateOtpPost(ctx context.Context, params CompatUsersUserIDActivateOtpPostParams) (res CompatUsersUserIDActivateOtpPostRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/compat/users/"
	{
		// Encode "user_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "user_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.UserID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/activate-otp"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, CompatUsersUserIDActivateOtpPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCompatUsersUserIDActivateOtpPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CompatUsersUserIDClearTrustedDevicesPost invokes POST /compat/users/{user_id}/clear-trusted-devices operation.
//
// ユーザの全信頼済みデバイスを削除する.
//
// POST /compat/users/{user_id}/clear-trusted-devices
func (c *Client) CompatUsersUserIDClearTrustedDevicesPost(ctx context.Context, params CompatUsersUserIDClearTrustedDevicesPostParams) (CompatUsersUserIDClearTrustedDevicesPostRes, error) {
	res, err := c.sendCompatUsersUserIDClearTrustedDevicesPost(ctx, params)
	return res, err
}

func (c *Client) sendCompatUsersUserIDClearTrustedDevicesPost(ctx context.Context, params CompatUsersUserIDClearTrustedDevicesPostParams) (res CompatUsersUserIDClearTrustedDevicesPostRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/compat/users/"
	{
		// Encode "user_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "user_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.UserID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/clear-trusted-devices"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, CompatUsersUserIDClearTrustedDevicesPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCompatUsersUserIDClearTrustedDevicesPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CompatUsersUserIDDeactivateOtpPost invokes POST /compat/users/{user_id}/deactivate-otp operation.
//
// 指定したユーザのワンタイムパスワード認証を無効化します。.
//
// POST /compat/users/{user_id}/deactivate-otp
func (c *Client) CompatUsersUserIDDeactivateOtpPost(ctx context.Context, params CompatUsersUserIDDeactivateOtpPostParams) (CompatUsersUserIDDeactivateOtpPostRes, error) {
	res, err := c.sendCompatUsersUserIDDeactivateOtpPost(ctx, params)
	return res, err
}

func (c *Client) sendCompatUsersUserIDDeactivateOtpPost(ctx context.Context, params CompatUsersUserIDDeactivateOtpPostParams) (res CompatUsersUserIDDeactivateOtpPostRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/compat/users/"
	{
		// Encode "user_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "user_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.UserID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/deactivate-otp"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, CompatUsersUserIDDeactivateOtpPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCompatUsersUserIDDeactivateOtpPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CompatUsersUserIDDelete invokes DELETE /compat/users/{user_id} operation.
//
// 指定したユーザを削除する.
//
// DELETE /compat/users/{user_id}
func (c *Client) CompatUsersUserIDDelete(ctx context.Context, params CompatUsersUserIDDeleteParams) (CompatUsersUserIDDeleteRes, error) {
	res, err := c.sendCompatUsersUserIDDelete(ctx, params)
	return res, err
}

func (c *Client) sendCompatUsersUserIDDelete(ctx context.Context, params CompatUsersUserIDDeleteParams) (res CompatUsersUserIDDeleteRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/compat/users/"
	{
		// Encode "user_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "user_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.UserID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, CompatUsersUserIDDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCompatUsersUserIDDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CompatUsersUserIDGet invokes GET /compat/users/{user_id} operation.
//
// 指定したユーザを取得する.
//
// GET /compat/users/{user_id}
func (c *Client) CompatUsersUserIDGet(ctx context.Context, params CompatUsersUserIDGetParams) (CompatUsersUserIDGetRes, error) {
	res, err := c.sendCompatUsersUserIDGet(ctx, params)
	return res, err
}

func (c *Client) sendCompatUsersUserIDGet(ctx context.Context, params CompatUsersUserIDGetParams) (res CompatUsersUserIDGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/compat/users/"
	{
		// Encode "user_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "user_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.UserID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, CompatUsersUserIDGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCompatUsersUserIDGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CompatUsersUserIDPut invokes PUT /compat/users/{user_id} operation.
//
// 指定したユーザを更新する.
//
// PUT /compat/users/{user_id}
func (c *Client) CompatUsersUserIDPut(ctx context.Context, request *CompatUsersUserIDPutReq, params CompatUsersUserIDPutParams) (CompatUsersUserIDPutRes, error) {
	res, err := c.sendCompatUsersUserIDPut(ctx, request, params)
	return res, err
}

func (c *Client) sendCompatUsersUserIDPut(ctx context.Context, request *CompatUsersUserIDPutReq, params CompatUsersUserIDPutParams) (res CompatUsersUserIDPutRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/compat/users/"
	{
		// Encode "user_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "user_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.UserID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCompatUsersUserIDPutRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, CompatUsersUserIDPutOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCompatUsersUserIDPutResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CompatUsersUserIDRecoveryCodePost invokes POST /compat/users/{user_id}/recovery-code operation.
//
// 指定したユーザの2要素認証リカバリコードを発行します。再実行するとリカバリコードが上書きされます。.
//
// POST /compat/users/{user_id}/recovery-code
func (c *Client) CompatUsersUserIDRecoveryCodePost(ctx context.Context, params CompatUsersUserIDRecoveryCodePostParams) (CompatUsersUserIDRecoveryCodePostRes, error) {
	res, err := c.sendCompatUsersUserIDRecoveryCodePost(ctx, params)
	return res, err
}

func (c *Client) sendCompatUsersUserIDRecoveryCodePost(ctx context.Context, params CompatUsersUserIDRecoveryCodePostParams) (res CompatUsersUserIDRecoveryCodePostRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/compat/users/"
	{
		// Encode "user_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "user_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.UserID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/recovery-code"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, CompatUsersUserIDRecoveryCodePostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCompatUsersUserIDRecoveryCodePostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CompatUsersUserIDRegisterEmailPost invokes POST /compat/users/{user_id}/register-email operation.
//
// ユーザにメールアドレスを登録する.
//
// POST /compat/users/{user_id}/register-email
func (c *Client) CompatUsersUserIDRegisterEmailPost(ctx context.Context, request *CompatUsersUserIDRegisterEmailPostReq, params CompatUsersUserIDRegisterEmailPostParams) (CompatUsersUserIDRegisterEmailPostRes, error) {
	res, err := c.sendCompatUsersUserIDRegisterEmailPost(ctx, request, params)
	return res, err
}

func (c *Client) sendCompatUsersUserIDRegisterEmailPost(ctx context.Context, request *CompatUsersUserIDRegisterEmailPostReq, params CompatUsersUserIDRegisterEmailPostParams) (res CompatUsersUserIDRegisterEmailPostRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/compat/users/"
	{
		// Encode "user_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "user_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.UserID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/register-email"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCompatUsersUserIDRegisterEmailPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, CompatUsersUserIDRegisterEmailPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCompatUsersUserIDRegisterEmailPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CompatUsersUserIDSecurityKeysGet invokes GET /compat/users/{user_id}/security-keys operation.
//
// ユーザのセキュリティキー一覧を取得する.
//
// GET /compat/users/{user_id}/security-keys
func (c *Client) CompatUsersUserIDSecurityKeysGet(ctx context.Context, params CompatUsersUserIDSecurityKeysGetParams) (CompatUsersUserIDSecurityKeysGetRes, error) {
	res, err := c.sendCompatUsersUserIDSecurityKeysGet(ctx, params)
	return res, err
}

func (c *Client) sendCompatUsersUserIDSecurityKeysGet(ctx context.Context, params CompatUsersUserIDSecurityKeysGetParams) (res CompatUsersUserIDSecurityKeysGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/compat/users/"
	{
		// Encode "user_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "user_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.UserID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/security-keys"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, CompatUsersUserIDSecurityKeysGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCompatUsersUserIDSecurityKeysGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CompatUsersUserIDSecurityKeysSecurityKeyIDDelete invokes DELETE /compat/users/{user_id}/security-keys/{security_key_id} operation.
//
// ユーザのセキュリティキーを削除する.
//
// DELETE /compat/users/{user_id}/security-keys/{security_key_id}
func (c *Client) CompatUsersUserIDSecurityKeysSecurityKeyIDDelete(ctx context.Context, params CompatUsersUserIDSecurityKeysSecurityKeyIDDeleteParams) (CompatUsersUserIDSecurityKeysSecurityKeyIDDeleteRes, error) {
	res, err := c.sendCompatUsersUserIDSecurityKeysSecurityKeyIDDelete(ctx, params)
	return res, err
}

func (c *Client) sendCompatUsersUserIDSecurityKeysSecurityKeyIDDelete(ctx context.Context, params CompatUsersUserIDSecurityKeysSecurityKeyIDDeleteParams) (res CompatUsersUserIDSecurityKeysSecurityKeyIDDeleteRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/compat/users/"
	{
		// Encode "user_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "user_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.UserID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/security-keys/"
	{
		// Encode "security_key_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "security_key_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.SecurityKeyID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, CompatUsersUserIDSecurityKeysSecurityKeyIDDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCompatUsersUserIDSecurityKeysSecurityKeyIDDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CompatUsersUserIDSecurityKeysSecurityKeyIDGet invokes GET /compat/users/{user_id}/security-keys/{security_key_id} operation.
//
// ユーザのセキュリティキーを取得する.
//
// GET /compat/users/{user_id}/security-keys/{security_key_id}
func (c *Client) CompatUsersUserIDSecurityKeysSecurityKeyIDGet(ctx context.Context, params CompatUsersUserIDSecurityKeysSecurityKeyIDGetParams) (CompatUsersUserIDSecurityKeysSecurityKeyIDGetRes, error) {
	res, err := c.sendCompatUsersUserIDSecurityKeysSecurityKeyIDGet(ctx, params)
	return res, err
}

func (c *Client) sendCompatUsersUserIDSecurityKeysSecurityKeyIDGet(ctx context.Context, params CompatUsersUserIDSecurityKeysSecurityKeyIDGetParams) (res CompatUsersUserIDSecurityKeysSecurityKeyIDGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/compat/users/"
	{
		// Encode "user_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "user_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.UserID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/security-keys/"
	{
		// Encode "security_key_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "security_key_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.SecurityKeyID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, CompatUsersUserIDSecurityKeysSecurityKeyIDGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCompatUsersUserIDSecurityKeysSecurityKeyIDGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CompatUsersUserIDSecurityKeysSecurityKeyIDPut invokes PUT /compat/users/{user_id}/security-keys/{security_key_id} operation.
//
// ユーザのセキュリティキーを更新する.
//
// PUT /compat/users/{user_id}/security-keys/{security_key_id}
func (c *Client) CompatUsersUserIDSecurityKeysSecurityKeyIDPut(ctx context.Context, request OptCompatUsersUserIDSecurityKeysSecurityKeyIDPutReq, params CompatUsersUserIDSecurityKeysSecurityKeyIDPutParams) (CompatUsersUserIDSecurityKeysSecurityKeyIDPutRes, error) {
	res, err := c.sendCompatUsersUserIDSecurityKeysSecurityKeyIDPut(ctx, request, params)
	return res, err
}

func (c *Client) sendCompatUsersUserIDSecurityKeysSecurityKeyIDPut(ctx context.Context, request OptCompatUsersUserIDSecurityKeysSecurityKeyIDPutReq, params CompatUsersUserIDSecurityKeysSecurityKeyIDPutParams) (res CompatUsersUserIDSecurityKeysSecurityKeyIDPutRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/compat/users/"
	{
		// Encode "user_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "user_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.UserID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/security-keys/"
	{
		// Encode "security_key_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "security_key_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.SecurityKeyID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCompatUsersUserIDSecurityKeysSecurityKeyIDPutRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, CompatUsersUserIDSecurityKeysSecurityKeyIDPutOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCompatUsersUserIDSecurityKeysSecurityKeyIDPutResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CompatUsersUserIDStartSecurityKeyRegistrationPost invokes POST /compat/users/{user_id}/start-security-key-registration operation.
//
// 指定したユーザのセキュリティキー登録を開始します。現時点でのセキュリティキーの最大登録数は1つです。
// WebAuthnのPublicKeyCredentialCreationOptions生成を行います。.
//
// POST /compat/users/{user_id}/start-security-key-registration
func (c *Client) CompatUsersUserIDStartSecurityKeyRegistrationPost(ctx context.Context, params CompatUsersUserIDStartSecurityKeyRegistrationPostParams) (CompatUsersUserIDStartSecurityKeyRegistrationPostRes, error) {
	res, err := c.sendCompatUsersUserIDStartSecurityKeyRegistrationPost(ctx, params)
	return res, err
}

func (c *Client) sendCompatUsersUserIDStartSecurityKeyRegistrationPost(ctx context.Context, params CompatUsersUserIDStartSecurityKeyRegistrationPostParams) (res CompatUsersUserIDStartSecurityKeyRegistrationPostRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/compat/users/"
	{
		// Encode "user_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "user_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.UserID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/start-security-key-registration"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, CompatUsersUserIDStartSecurityKeyRegistrationPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCompatUsersUserIDStartSecurityKeyRegistrationPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CompatUsersUserIDTrustedDevicesGet invokes GET /compat/users/{user_id}/trusted-devices operation.
//
// ユーザの信頼済みデバイス一覧を取得する.
//
// GET /compat/users/{user_id}/trusted-devices
func (c *Client) CompatUsersUserIDTrustedDevicesGet(ctx context.Context, params CompatUsersUserIDTrustedDevicesGetParams) (CompatUsersUserIDTrustedDevicesGetRes, error) {
	res, err := c.sendCompatUsersUserIDTrustedDevicesGet(ctx, params)
	return res, err
}

func (c *Client) sendCompatUsersUserIDTrustedDevicesGet(ctx context.Context, params CompatUsersUserIDTrustedDevicesGetParams) (res CompatUsersUserIDTrustedDevicesGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/compat/users/"
	{
		// Encode "user_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "user_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.UserID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/trusted-devices"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, CompatUsersUserIDTrustedDevicesGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCompatUsersUserIDTrustedDevicesGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CompatUsersUserIDTrustedDevicesTrustedDeviceIDDelete invokes DELETE /compat/users/{user_id}/trusted-devices/{trusted_device_id} operation.
//
// ユーザの信頼済みデバイスを削除する.
//
// DELETE /compat/users/{user_id}/trusted-devices/{trusted_device_id}
func (c *Client) CompatUsersUserIDTrustedDevicesTrustedDeviceIDDelete(ctx context.Context, params CompatUsersUserIDTrustedDevicesTrustedDeviceIDDeleteParams) (CompatUsersUserIDTrustedDevicesTrustedDeviceIDDeleteRes, error) {
	res, err := c.sendCompatUsersUserIDTrustedDevicesTrustedDeviceIDDelete(ctx, params)
	return res, err
}

func (c *Client) sendCompatUsersUserIDTrustedDevicesTrustedDeviceIDDelete(ctx context.Context, params CompatUsersUserIDTrustedDevicesTrustedDeviceIDDeleteParams) (res CompatUsersUserIDTrustedDevicesTrustedDeviceIDDeleteRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/compat/users/"
	{
		// Encode "user_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "user_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.UserID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/trusted-devices/"
	{
		// Encode "trusted_device_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "trusted_device_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.TrustedDeviceID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, CompatUsersUserIDTrustedDevicesTrustedDeviceIDDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCompatUsersUserIDTrustedDevicesTrustedDeviceIDDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CompatUsersUserIDUnregisterEmailPost invokes POST /compat/users/{user_id}/unregister-email operation.
//
// ユーザのメールアドレスを削除する.
//
// POST /compat/users/{user_id}/unregister-email
func (c *Client) CompatUsersUserIDUnregisterEmailPost(ctx context.Context, params CompatUsersUserIDUnregisterEmailPostParams) (CompatUsersUserIDUnregisterEmailPostRes, error) {
	res, err := c.sendCompatUsersUserIDUnregisterEmailPost(ctx, params)
	return res, err
}

func (c *Client) sendCompatUsersUserIDUnregisterEmailPost(ctx context.Context, params CompatUsersUserIDUnregisterEmailPostParams) (res CompatUsersUserIDUnregisterEmailPostRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/compat/users/"
	{
		// Encode "user_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "user_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.UserID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/unregister-email"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, CompatUsersUserIDUnregisterEmailPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCompatUsersUserIDUnregisterEmailPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CompatUsersUserIDValidateSecurityKeyRegistrationPost invokes POST /compat/users/{user_id}/validate-security-key-registration operation.
//
// 指定したユーザのセキュリティキー登録を完了します。
// ブラウザの `navigator.credentials.create()` で生成された[認証情報](https://www.w3.
// org/TR/webauthn-2/#publickeycredential)を受け取って検証します。.
//
// POST /compat/users/{user_id}/validate-security-key-registration
func (c *Client) CompatUsersUserIDValidateSecurityKeyRegistrationPost(ctx context.Context, request *CompatUsersUserIDValidateSecurityKeyRegistrationPostReq, params CompatUsersUserIDValidateSecurityKeyRegistrationPostParams) (CompatUsersUserIDValidateSecurityKeyRegistrationPostRes, error) {
	res, err := c.sendCompatUsersUserIDValidateSecurityKeyRegistrationPost(ctx, request, params)
	return res, err
}

func (c *Client) sendCompatUsersUserIDValidateSecurityKeyRegistrationPost(ctx context.Context, request *CompatUsersUserIDValidateSecurityKeyRegistrationPostReq, params CompatUsersUserIDValidateSecurityKeyRegistrationPostParams) (res CompatUsersUserIDValidateSecurityKeyRegistrationPostRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/compat/users/"
	{
		// Encode "user_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "user_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.UserID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/validate-security-key-registration"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCompatUsersUserIDValidateSecurityKeyRegistrationPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, CompatUsersUserIDValidateSecurityKeyRegistrationPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCompatUsersUserIDValidateSecurityKeyRegistrationPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DisableServicePolicyPost invokes POST /disable-service-policy operation.
//
// サービスポリシーを無効化する.
//
// POST /disable-service-policy
func (c *Client) DisableServicePolicyPost(ctx context.Context) (DisableServicePolicyPostRes, error) {
	res, err := c.sendDisableServicePolicyPost(ctx)
	return res, err
}

func (c *Client) sendDisableServicePolicyPost(ctx context.Context) (res DisableServicePolicyPostRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/disable-service-policy"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, DisableServicePolicyPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDisableServicePolicyPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnableServicePolicyPost invokes POST /enable-service-policy operation.
//
// サービスポリシーを有効化する.
//
// POST /enable-service-policy
func (c *Client) EnableServicePolicyPost(ctx context.Context) (EnableServicePolicyPostRes, error) {
	res, err := c.sendEnableServicePolicyPost(ctx)
	return res, err
}

func (c *Client) sendEnableServicePolicyPost(ctx context.Context) (res EnableServicePolicyPostRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/enable-service-policy"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, EnableServicePolicyPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEnableServicePolicyPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// FoldersFolderIDDelete invokes DELETE /folders/{folder_id} operation.
//
// フォルダを削除する.
//
// DELETE /folders/{folder_id}
func (c *Client) FoldersFolderIDDelete(ctx context.Context, params FoldersFolderIDDeleteParams) (FoldersFolderIDDeleteRes, error) {
	res, err := c.sendFoldersFolderIDDelete(ctx, params)
	return res, err
}

func (c *Client) sendFoldersFolderIDDelete(ctx context.Context, params FoldersFolderIDDeleteParams) (res FoldersFolderIDDeleteRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/folders/"
	{
		// Encode "folder_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "folder_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.FolderID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, FoldersFolderIDDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeFoldersFolderIDDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// FoldersFolderIDGet invokes GET /folders/{folder_id} operation.
//
// 特定のフォルダの情報を取得する.
//
// GET /folders/{folder_id}
func (c *Client) FoldersFolderIDGet(ctx context.Context, params FoldersFolderIDGetParams) (FoldersFolderIDGetRes, error) {
	res, err := c.sendFoldersFolderIDGet(ctx, params)
	return res, err
}

func (c *Client) sendFoldersFolderIDGet(ctx context.Context, params FoldersFolderIDGetParams) (res FoldersFolderIDGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/folders/"
	{
		// Encode "folder_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "folder_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.FolderID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, FoldersFolderIDGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeFoldersFolderIDGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// FoldersFolderIDIamPolicyGet invokes GET /folders/{folder_id}/iam-policy operation.
//
// フォルダIAMポリシーを取得する.
//
// GET /folders/{folder_id}/iam-policy
func (c *Client) FoldersFolderIDIamPolicyGet(ctx context.Context, params FoldersFolderIDIamPolicyGetParams) (FoldersFolderIDIamPolicyGetRes, error) {
	res, err := c.sendFoldersFolderIDIamPolicyGet(ctx, params)
	return res, err
}

func (c *Client) sendFoldersFolderIDIamPolicyGet(ctx context.Context, params FoldersFolderIDIamPolicyGetParams) (res FoldersFolderIDIamPolicyGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/folders/"
	{
		// Encode "folder_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "folder_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.FolderID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/iam-policy"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, FoldersFolderIDIamPolicyGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeFoldersFolderIDIamPolicyGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// FoldersFolderIDIamPolicyPut invokes PUT /folders/{folder_id}/iam-policy operation.
//
// フォルダIAMポリシーを更新する.
//
// PUT /folders/{folder_id}/iam-policy
func (c *Client) FoldersFolderIDIamPolicyPut(ctx context.Context, request *FoldersFolderIDIamPolicyPutReq, params FoldersFolderIDIamPolicyPutParams) (FoldersFolderIDIamPolicyPutRes, error) {
	res, err := c.sendFoldersFolderIDIamPolicyPut(ctx, request, params)
	return res, err
}

func (c *Client) sendFoldersFolderIDIamPolicyPut(ctx context.Context, request *FoldersFolderIDIamPolicyPutReq, params FoldersFolderIDIamPolicyPutParams) (res FoldersFolderIDIamPolicyPutRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/folders/"
	{
		// Encode "folder_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "folder_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.FolderID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/iam-policy"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeFoldersFolderIDIamPolicyPutRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, FoldersFolderIDIamPolicyPutOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeFoldersFolderIDIamPolicyPutResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// FoldersFolderIDPut invokes PUT /folders/{folder_id} operation.
//
// 特定のフォルダの情報を更新する.
//
// PUT /folders/{folder_id}
func (c *Client) FoldersFolderIDPut(ctx context.Context, request *FoldersFolderIDPutReq, params FoldersFolderIDPutParams) (FoldersFolderIDPutRes, error) {
	res, err := c.sendFoldersFolderIDPut(ctx, request, params)
	return res, err
}

func (c *Client) sendFoldersFolderIDPut(ctx context.Context, request *FoldersFolderIDPutReq, params FoldersFolderIDPutParams) (res FoldersFolderIDPutRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/folders/"
	{
		// Encode "folder_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "folder_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.FolderID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeFoldersFolderIDPutRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, FoldersFolderIDPutOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeFoldersFolderIDPutResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// FoldersGet invokes GET /folders operation.
//
// フォルダ一覧を取得する.
//
// GET /folders
func (c *Client) FoldersGet(ctx context.Context, params FoldersGetParams) (FoldersGetRes, error) {
	res, err := c.sendFoldersGet(ctx, params)
	return res, err
}

func (c *Client) sendFoldersGet(ctx context.Context, params FoldersGetParams) (res FoldersGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/folders"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "folder_name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "folder_name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.FolderName.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "parent_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "parent_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ParentID.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, FoldersGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeFoldersGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// FoldersPost invokes POST /folders operation.
//
// フォルダを作成する.
//
// POST /folders
func (c *Client) FoldersPost(ctx context.Context, request *FoldersPostReq) (FoldersPostRes, error) {
	res, err := c.sendFoldersPost(ctx, request)
	return res, err
}

func (c *Client) sendFoldersPost(ctx context.Context, request *FoldersPostReq) (res FoldersPostRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/folders"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeFoldersPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, FoldersPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeFoldersPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GroupsGet invokes GET /groups operation.
//
// グループ一覧を取得する.
//
// GET /groups
func (c *Client) GroupsGet(ctx context.Context, params GroupsGetParams) (GroupsGetRes, error) {
	res, err := c.sendGroupsGet(ctx, params)
	return res, err
}

func (c *Client) sendGroupsGet(ctx context.Context, params GroupsGetParams) (res GroupsGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/groups"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "ordering" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "ordering",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Ordering.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "compat_user_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "compat_user_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.CompatUserID.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, GroupsGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGroupsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GroupsGroupIDDelete invokes DELETE /groups/{group_id} operation.
//
// 指定したグループを削除する.
//
// DELETE /groups/{group_id}
func (c *Client) GroupsGroupIDDelete(ctx context.Context, params GroupsGroupIDDeleteParams) (GroupsGroupIDDeleteRes, error) {
	res, err := c.sendGroupsGroupIDDelete(ctx, params)
	return res, err
}

func (c *Client) sendGroupsGroupIDDelete(ctx context.Context, params GroupsGroupIDDeleteParams) (res GroupsGroupIDDeleteRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/groups/"
	{
		// Encode "group_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.GroupID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, GroupsGroupIDDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGroupsGroupIDDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GroupsGroupIDGet invokes GET /groups/{group_id} operation.
//
// 指定したグループを取得する.
//
// GET /groups/{group_id}
func (c *Client) GroupsGroupIDGet(ctx context.Context, params GroupsGroupIDGetParams) (GroupsGroupIDGetRes, error) {
	res, err := c.sendGroupsGroupIDGet(ctx, params)
	return res, err
}

func (c *Client) sendGroupsGroupIDGet(ctx context.Context, params GroupsGroupIDGetParams) (res GroupsGroupIDGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/groups/"
	{
		// Encode "group_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.GroupID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, GroupsGroupIDGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGroupsGroupIDGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GroupsGroupIDMembershipsGet invokes GET /groups/{group_id}/memberships operation.
//
// グループの所属情報を取得する.
//
// GET /groups/{group_id}/memberships
func (c *Client) GroupsGroupIDMembershipsGet(ctx context.Context, params GroupsGroupIDMembershipsGetParams) (GroupsGroupIDMembershipsGetRes, error) {
	res, err := c.sendGroupsGroupIDMembershipsGet(ctx, params)
	return res, err
}

func (c *Client) sendGroupsGroupIDMembershipsGet(ctx context.Context, params GroupsGroupIDMembershipsGetParams) (res GroupsGroupIDMembershipsGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/groups/"
	{
		// Encode "group_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.GroupID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/memberships"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, GroupsGroupIDMembershipsGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGroupsGroupIDMembershipsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GroupsGroupIDMembershipsPut invokes PUT /groups/{group_id}/memberships operation.
//
// グループの所属情報を更新する.
//
// PUT /groups/{group_id}/memberships
func (c *Client) GroupsGroupIDMembershipsPut(ctx context.Context, request *GroupsGroupIDMembershipsPutReq, params GroupsGroupIDMembershipsPutParams) (GroupsGroupIDMembershipsPutRes, error) {
	res, err := c.sendGroupsGroupIDMembershipsPut(ctx, request, params)
	return res, err
}

func (c *Client) sendGroupsGroupIDMembershipsPut(ctx context.Context, request *GroupsGroupIDMembershipsPutReq, params GroupsGroupIDMembershipsPutParams) (res GroupsGroupIDMembershipsPutRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/groups/"
	{
		// Encode "group_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.GroupID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/memberships"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGroupsGroupIDMembershipsPutRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, GroupsGroupIDMembershipsPutOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGroupsGroupIDMembershipsPutResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GroupsGroupIDPut invokes PUT /groups/{group_id} operation.
//
// 指定したグループを更新する.
//
// PUT /groups/{group_id}
func (c *Client) GroupsGroupIDPut(ctx context.Context, request *GroupsGroupIDPutReq, params GroupsGroupIDPutParams) (GroupsGroupIDPutRes, error) {
	res, err := c.sendGroupsGroupIDPut(ctx, request, params)
	return res, err
}

func (c *Client) sendGroupsGroupIDPut(ctx context.Context, request *GroupsGroupIDPutReq, params GroupsGroupIDPutParams) (res GroupsGroupIDPutRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/groups/"
	{
		// Encode "group_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "group_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.GroupID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGroupsGroupIDPutRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, GroupsGroupIDPutOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGroupsGroupIDPutResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GroupsPost invokes POST /groups operation.
//
// グループを作成する.
//
// POST /groups
func (c *Client) GroupsPost(ctx context.Context, request *GroupsPostReq) (GroupsPostRes, error) {
	res, err := c.sendGroupsPost(ctx, request)
	return res, err
}

func (c *Client) sendGroupsPost(ctx context.Context, request *GroupsPostReq) (res GroupsPostRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/groups"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGroupsPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, GroupsPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGroupsPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IDRolesGet invokes GET /id-roles operation.
//
// IDロール一覧を取得する.
//
// GET /id-roles
func (c *Client) IDRolesGet(ctx context.Context, params IDRolesGetParams) (IDRolesGetRes, error) {
	res, err := c.sendIDRolesGet(ctx, params)
	return res, err
}

func (c *Client) sendIDRolesGet(ctx context.Context, params IDRolesGetParams) (res IDRolesGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/id-roles"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, IDRolesGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeIDRolesGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IDRolesIDRoleIDGet invokes GET /id-roles/{id_role_id} operation.
//
// 指定したIDロールを取得する.
//
// GET /id-roles/{id_role_id}
func (c *Client) IDRolesIDRoleIDGet(ctx context.Context, params IDRolesIDRoleIDGetParams) (IDRolesIDRoleIDGetRes, error) {
	res, err := c.sendIDRolesIDRoleIDGet(ctx, params)
	return res, err
}

func (c *Client) sendIDRolesIDRoleIDGet(ctx context.Context, params IDRolesIDRoleIDGetParams) (res IDRolesIDRoleIDGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/id-roles/"
	{
		// Encode "id_role_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id_role_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.IDRoleID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, IDRolesIDRoleIDGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeIDRolesIDRoleIDGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IamRolesGet invokes GET /iam-roles operation.
//
// IAMロール一覧を取得する.
//
// GET /iam-roles
func (c *Client) IamRolesGet(ctx context.Context, params IamRolesGetParams) (IamRolesGetRes, error) {
	res, err := c.sendIamRolesGet(ctx, params)
	return res, err
}

func (c *Client) sendIamRolesGet(ctx context.Context, params IamRolesGetParams) (res IamRolesGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/iam-roles"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, IamRolesGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeIamRolesGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// IamRolesIamRoleIDGet invokes GET /iam-roles/{iam_role_id} operation.
//
// 指定したIAMロールを取得する.
//
// GET /iam-roles/{iam_role_id}
func (c *Client) IamRolesIamRoleIDGet(ctx context.Context, params IamRolesIamRoleIDGetParams) (IamRolesIamRoleIDGetRes, error) {
	res, err := c.sendIamRolesIamRoleIDGet(ctx, params)
	return res, err
}

func (c *Client) sendIamRolesIamRoleIDGet(ctx context.Context, params IamRolesIamRoleIDGetParams) (res IamRolesIamRoleIDGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/iam-roles/"
	{
		// Encode "iam_role_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "iam_role_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.IamRoleID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, IamRolesIamRoleIDGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeIamRolesIamRoleIDGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MoveFoldersPost invokes POST /move-folders operation.
//
// フォルダを移動する.
//
// POST /move-folders
func (c *Client) MoveFoldersPost(ctx context.Context, request *MoveFolders) (MoveFoldersPostRes, error) {
	res, err := c.sendMoveFoldersPost(ctx, request)
	return res, err
}

func (c *Client) sendMoveFoldersPost(ctx context.Context, request *MoveFolders) (res MoveFoldersPostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/move-folders"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeMoveFoldersPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, MoveFoldersPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeMoveFoldersPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MoveProjectsPost invokes POST /move-projects operation.
//
// プロジェクトを一括で移動する.
//
// POST /move-projects
func (c *Client) MoveProjectsPost(ctx context.Context, request *MoveProjects) (MoveProjectsPostRes, error) {
	res, err := c.sendMoveProjectsPost(ctx, request)
	return res, err
}

func (c *Client) sendMoveProjectsPost(ctx context.Context, request *MoveProjects) (res MoveProjectsPostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/move-projects"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeMoveProjectsPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, MoveProjectsPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeMoveProjectsPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrganizationAuthConditionsGet invokes GET /organization-auth-conditions operation.
//
// 組織の認証条件を取得する.
//
// GET /organization-auth-conditions
func (c *Client) OrganizationAuthConditionsGet(ctx context.Context) (OrganizationAuthConditionsGetRes, error) {
	res, err := c.sendOrganizationAuthConditionsGet(ctx)
	return res, err
}

func (c *Client) sendOrganizationAuthConditionsGet(ctx context.Context) (res OrganizationAuthConditionsGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/organization-auth-conditions"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, OrganizationAuthConditionsGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOrganizationAuthConditionsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrganizationAuthConditionsPut invokes PUT /organization-auth-conditions operation.
//
// 組織の認証条件を更新する.
//
// PUT /organization-auth-conditions
func (c *Client) OrganizationAuthConditionsPut(ctx context.Context, request *AuthConditions) (OrganizationAuthConditionsPutRes, error) {
	res, err := c.sendOrganizationAuthConditionsPut(ctx, request)
	return res, err
}

func (c *Client) sendOrganizationAuthConditionsPut(ctx context.Context, request *AuthConditions) (res OrganizationAuthConditionsPutRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/organization-auth-conditions"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeOrganizationAuthConditionsPutRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, OrganizationAuthConditionsPutOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOrganizationAuthConditionsPutResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrganizationGet invokes GET /organization operation.
//
// 組織を取得する.
//
// GET /organization
func (c *Client) OrganizationGet(ctx context.Context) (OrganizationGetRes, error) {
	res, err := c.sendOrganizationGet(ctx)
	return res, err
}

func (c *Client) sendOrganizationGet(ctx context.Context) (res OrganizationGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/organization"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, OrganizationGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOrganizationGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrganizationIDPolicyGet invokes GET /organization-id-policy operation.
//
// 組織IDポリシーを取得する.
//
// GET /organization-id-policy
func (c *Client) OrganizationIDPolicyGet(ctx context.Context) (OrganizationIDPolicyGetRes, error) {
	res, err := c.sendOrganizationIDPolicyGet(ctx)
	return res, err
}

func (c *Client) sendOrganizationIDPolicyGet(ctx context.Context) (res OrganizationIDPolicyGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/organization-id-policy"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, OrganizationIDPolicyGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOrganizationIDPolicyGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrganizationIDPolicyPut invokes PUT /organization-id-policy operation.
//
// 組織IDポリシーを更新する.
//
// PUT /organization-id-policy
func (c *Client) OrganizationIDPolicyPut(ctx context.Context, request *OrganizationIDPolicyPutReq) (OrganizationIDPolicyPutRes, error) {
	res, err := c.sendOrganizationIDPolicyPut(ctx, request)
	return res, err
}

func (c *Client) sendOrganizationIDPolicyPut(ctx context.Context, request *OrganizationIDPolicyPutReq) (res OrganizationIDPolicyPutRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/organization-id-policy"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeOrganizationIDPolicyPutRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, OrganizationIDPolicyPutOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOrganizationIDPolicyPutResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrganizationIamPolicyGet invokes GET /organization-iam-policy operation.
//
// 組織IAMポリシーを取得する.
//
// GET /organization-iam-policy
func (c *Client) OrganizationIamPolicyGet(ctx context.Context) (OrganizationIamPolicyGetRes, error) {
	res, err := c.sendOrganizationIamPolicyGet(ctx)
	return res, err
}

func (c *Client) sendOrganizationIamPolicyGet(ctx context.Context) (res OrganizationIamPolicyGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/organization-iam-policy"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, OrganizationIamPolicyGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOrganizationIamPolicyGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrganizationIamPolicyPut invokes PUT /organization-iam-policy operation.
//
// 組織IAMポリシーを更新する.
//
// PUT /organization-iam-policy
func (c *Client) OrganizationIamPolicyPut(ctx context.Context, request *OrganizationIamPolicyPutReq) (OrganizationIamPolicyPutRes, error) {
	res, err := c.sendOrganizationIamPolicyPut(ctx, request)
	return res, err
}

func (c *Client) sendOrganizationIamPolicyPut(ctx context.Context, request *OrganizationIamPolicyPutReq) (res OrganizationIamPolicyPutRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/organization-iam-policy"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeOrganizationIamPolicyPutRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, OrganizationIamPolicyPutOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOrganizationIamPolicyPutResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrganizationPasswordPolicyGet invokes GET /organization-password-policy operation.
//
// 組織のパスワードポリシーを取得する.
//
// GET /organization-password-policy
func (c *Client) OrganizationPasswordPolicyGet(ctx context.Context) (OrganizationPasswordPolicyGetRes, error) {
	res, err := c.sendOrganizationPasswordPolicyGet(ctx)
	return res, err
}

func (c *Client) sendOrganizationPasswordPolicyGet(ctx context.Context) (res OrganizationPasswordPolicyGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/organization-password-policy"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, OrganizationPasswordPolicyGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOrganizationPasswordPolicyGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrganizationPasswordPolicyPut invokes PUT /organization-password-policy operation.
//
// 組織のパスワードポリシーを更新する.
//
// PUT /organization-password-policy
func (c *Client) OrganizationPasswordPolicyPut(ctx context.Context) (OrganizationPasswordPolicyPutRes, error) {
	res, err := c.sendOrganizationPasswordPolicyPut(ctx)
	return res, err
}

func (c *Client) sendOrganizationPasswordPolicyPut(ctx context.Context) (res OrganizationPasswordPolicyPutRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/organization-password-policy"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, OrganizationPasswordPolicyPutOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOrganizationPasswordPolicyPutResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrganizationPut invokes PUT /organization operation.
//
// 組織を更新する.
//
// PUT /organization
func (c *Client) OrganizationPut(ctx context.Context, request *OrganizationPutReq) (OrganizationPutRes, error) {
	res, err := c.sendOrganizationPut(ctx, request)
	return res, err
}

func (c *Client) sendOrganizationPut(ctx context.Context, request *OrganizationPutReq) (res OrganizationPutRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/organization"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeOrganizationPutRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, OrganizationPutOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOrganizationPutResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrganizationServicePolicyGet invokes GET /organization-service-policy operation.
//
// 組織のサービスポリシーを構成するルールを取得する.
//
// GET /organization-service-policy
func (c *Client) OrganizationServicePolicyGet(ctx context.Context, params OrganizationServicePolicyGetParams) (OrganizationServicePolicyGetRes, error) {
	res, err := c.sendOrganizationServicePolicyGet(ctx, params)
	return res, err
}

func (c *Client) sendOrganizationServicePolicyGet(ctx context.Context, params OrganizationServicePolicyGetParams) (res OrganizationServicePolicyGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/organization-service-policy"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "is_active" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "is_active",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IsActive.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "is_dry_run" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "is_dry_run",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IsDryRun.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Name.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "code" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "code",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Code.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Type.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, OrganizationServicePolicyGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOrganizationServicePolicyGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OrganizationServicePolicyPut invokes PUT /organization-service-policy operation.
//
// 組織のサービスポリシーを構成するルールの設定値を更新するエンドポイント。設定を更新するルールをリクエストボディで指定する.
//
// PUT /organization-service-policy
func (c *Client) OrganizationServicePolicyPut(ctx context.Context, request *OrganizationServicePolicyPutReq) (OrganizationServicePolicyPutRes, error) {
	res, err := c.sendOrganizationServicePolicyPut(ctx, request)
	return res, err
}

func (c *Client) sendOrganizationServicePolicyPut(ctx context.Context, request *OrganizationServicePolicyPutReq) (res OrganizationServicePolicyPutRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/organization-service-policy"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeOrganizationServicePolicyPutRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, OrganizationServicePolicyPutOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOrganizationServicePolicyPutResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProjectsGet invokes GET /projects operation.
//
// プロジェクト一覧を取得する.
//
// GET /projects
func (c *Client) ProjectsGet(ctx context.Context, params ProjectsGetParams) (ProjectsGetRes, error) {
	res, err := c.sendProjectsGet(ctx, params)
	return res, err
}

func (c *Client) sendProjectsGet(ctx context.Context, params ProjectsGetParams) (res ProjectsGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/projects"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "ordering" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "ordering",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Ordering.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "iam_role" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "iam_role",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IamRole.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "parent_folder_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "parent_folder_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ParentFolderID.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, ProjectsGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeProjectsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProjectsPost invokes POST /projects operation.
//
// プロジェクトを作成する.
//
// POST /projects
func (c *Client) ProjectsPost(ctx context.Context, request *ProjectsPostReq) (ProjectsPostRes, error) {
	res, err := c.sendProjectsPost(ctx, request)
	return res, err
}

func (c *Client) sendProjectsPost(ctx context.Context, request *ProjectsPostReq) (res ProjectsPostRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/projects"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeProjectsPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, ProjectsPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeProjectsPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProjectsProjectIDDelete invokes DELETE /projects/{project_id} operation.
//
// 指定したプロジェクトを削除する.
//
// DELETE /projects/{project_id}
func (c *Client) ProjectsProjectIDDelete(ctx context.Context, params ProjectsProjectIDDeleteParams) (ProjectsProjectIDDeleteRes, error) {
	res, err := c.sendProjectsProjectIDDelete(ctx, params)
	return res, err
}

func (c *Client) sendProjectsProjectIDDelete(ctx context.Context, params ProjectsProjectIDDeleteParams) (res ProjectsProjectIDDeleteRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/projects/"
	{
		// Encode "project_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ProjectID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, ProjectsProjectIDDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeProjectsProjectIDDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProjectsProjectIDGet invokes GET /projects/{project_id} operation.
//
// 指定したプロジェクトを取得する.
//
// GET /projects/{project_id}
func (c *Client) ProjectsProjectIDGet(ctx context.Context, params ProjectsProjectIDGetParams) (ProjectsProjectIDGetRes, error) {
	res, err := c.sendProjectsProjectIDGet(ctx, params)
	return res, err
}

func (c *Client) sendProjectsProjectIDGet(ctx context.Context, params ProjectsProjectIDGetParams) (res ProjectsProjectIDGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/projects/"
	{
		// Encode "project_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ProjectID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, ProjectsProjectIDGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeProjectsProjectIDGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProjectsProjectIDIamPolicyGet invokes GET /projects/{project_id}/iam-policy operation.
//
// プロジェクトIAMポリシーを取得する.
//
// GET /projects/{project_id}/iam-policy
func (c *Client) ProjectsProjectIDIamPolicyGet(ctx context.Context, params ProjectsProjectIDIamPolicyGetParams) (ProjectsProjectIDIamPolicyGetRes, error) {
	res, err := c.sendProjectsProjectIDIamPolicyGet(ctx, params)
	return res, err
}

func (c *Client) sendProjectsProjectIDIamPolicyGet(ctx context.Context, params ProjectsProjectIDIamPolicyGetParams) (res ProjectsProjectIDIamPolicyGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/projects/"
	{
		// Encode "project_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ProjectID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/iam-policy"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, ProjectsProjectIDIamPolicyGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeProjectsProjectIDIamPolicyGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProjectsProjectIDIamPolicyPut invokes PUT /projects/{project_id}/iam-policy operation.
//
// プロジェクトIAMポリシーを更新する.
//
// PUT /projects/{project_id}/iam-policy
func (c *Client) ProjectsProjectIDIamPolicyPut(ctx context.Context, request *ProjectsProjectIDIamPolicyPutReq, params ProjectsProjectIDIamPolicyPutParams) (ProjectsProjectIDIamPolicyPutRes, error) {
	res, err := c.sendProjectsProjectIDIamPolicyPut(ctx, request, params)
	return res, err
}

func (c *Client) sendProjectsProjectIDIamPolicyPut(ctx context.Context, request *ProjectsProjectIDIamPolicyPutReq, params ProjectsProjectIDIamPolicyPutParams) (res ProjectsProjectIDIamPolicyPutRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/projects/"
	{
		// Encode "project_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ProjectID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/iam-policy"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeProjectsProjectIDIamPolicyPutRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, ProjectsProjectIDIamPolicyPutOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeProjectsProjectIDIamPolicyPutResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProjectsProjectIDPut invokes PUT /projects/{project_id} operation.
//
// 指定したプロジェクトを更新する.
//
// PUT /projects/{project_id}
func (c *Client) ProjectsProjectIDPut(ctx context.Context, request *ProjectsProjectIDPutReq, params ProjectsProjectIDPutParams) (ProjectsProjectIDPutRes, error) {
	res, err := c.sendProjectsProjectIDPut(ctx, request, params)
	return res, err
}

func (c *Client) sendProjectsProjectIDPut(ctx context.Context, request *ProjectsProjectIDPutReq, params ProjectsProjectIDPutParams) (res ProjectsProjectIDPutRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/projects/"
	{
		// Encode "project_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "project_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ProjectID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeProjectsProjectIDPutRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, ProjectsProjectIDPutOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeProjectsProjectIDPutResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SSOProfilesGet invokes GET /sso-profiles operation.
//
// SSOプロファイル一覧を取得する.
//
// GET /sso-profiles
func (c *Client) SSOProfilesGet(ctx context.Context, params SSOProfilesGetParams) (SSOProfilesGetRes, error) {
	res, err := c.sendSSOProfilesGet(ctx, params)
	return res, err
}

func (c *Client) sendSSOProfilesGet(ctx context.Context, params SSOProfilesGetParams) (res SSOProfilesGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/sso-profiles"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, SSOProfilesGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSSOProfilesGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SSOProfilesPost invokes POST /sso-profiles operation.
//
// SSOプロファイルを作成する.
//
// POST /sso-profiles
func (c *Client) SSOProfilesPost(ctx context.Context, request *SSOProfilesPostReq) (SSOProfilesPostRes, error) {
	res, err := c.sendSSOProfilesPost(ctx, request)
	return res, err
}

func (c *Client) sendSSOProfilesPost(ctx context.Context, request *SSOProfilesPostReq) (res SSOProfilesPostRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/sso-profiles"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSSOProfilesPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, SSOProfilesPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSSOProfilesPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SSOProfilesSSOProfileIDAssignPost invokes POST /sso-profiles/{sso_profile_id}/assign operation.
//
// 割当を行うと会員配下のクラウドユーザすべてで該当SSOプロファイルが有効になります。.
//
// POST /sso-profiles/{sso_profile_id}/assign
func (c *Client) SSOProfilesSSOProfileIDAssignPost(ctx context.Context, params SSOProfilesSSOProfileIDAssignPostParams) (SSOProfilesSSOProfileIDAssignPostRes, error) {
	res, err := c.sendSSOProfilesSSOProfileIDAssignPost(ctx, params)
	return res, err
}

func (c *Client) sendSSOProfilesSSOProfileIDAssignPost(ctx context.Context, params SSOProfilesSSOProfileIDAssignPostParams) (res SSOProfilesSSOProfileIDAssignPostRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/sso-profiles/"
	{
		// Encode "sso_profile_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "sso_profile_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.SSOProfileID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/assign"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, SSOProfilesSSOProfileIDAssignPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSSOProfilesSSOProfileIDAssignPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SSOProfilesSSOProfileIDDelete invokes DELETE /sso-profiles/{sso_profile_id} operation.
//
// 指定したSSOプロファイルを削除する.
//
// DELETE /sso-profiles/{sso_profile_id}
func (c *Client) SSOProfilesSSOProfileIDDelete(ctx context.Context, params SSOProfilesSSOProfileIDDeleteParams) (SSOProfilesSSOProfileIDDeleteRes, error) {
	res, err := c.sendSSOProfilesSSOProfileIDDelete(ctx, params)
	return res, err
}

func (c *Client) sendSSOProfilesSSOProfileIDDelete(ctx context.Context, params SSOProfilesSSOProfileIDDeleteParams) (res SSOProfilesSSOProfileIDDeleteRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/sso-profiles/"
	{
		// Encode "sso_profile_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "sso_profile_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.SSOProfileID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, SSOProfilesSSOProfileIDDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSSOProfilesSSOProfileIDDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SSOProfilesSSOProfileIDGet invokes GET /sso-profiles/{sso_profile_id} operation.
//
// 指定したSSOプロファイルを取得する.
//
// GET /sso-profiles/{sso_profile_id}
func (c *Client) SSOProfilesSSOProfileIDGet(ctx context.Context, params SSOProfilesSSOProfileIDGetParams) (SSOProfilesSSOProfileIDGetRes, error) {
	res, err := c.sendSSOProfilesSSOProfileIDGet(ctx, params)
	return res, err
}

func (c *Client) sendSSOProfilesSSOProfileIDGet(ctx context.Context, params SSOProfilesSSOProfileIDGetParams) (res SSOProfilesSSOProfileIDGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/sso-profiles/"
	{
		// Encode "sso_profile_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "sso_profile_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.SSOProfileID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, SSOProfilesSSOProfileIDGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSSOProfilesSSOProfileIDGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SSOProfilesSSOProfileIDPut invokes PUT /sso-profiles/{sso_profile_id} operation.
//
// 指定したSSOプロファイルを更新する.
//
// PUT /sso-profiles/{sso_profile_id}
func (c *Client) SSOProfilesSSOProfileIDPut(ctx context.Context, request *SSOProfilesSSOProfileIDPutReq, params SSOProfilesSSOProfileIDPutParams) (SSOProfilesSSOProfileIDPutRes, error) {
	res, err := c.sendSSOProfilesSSOProfileIDPut(ctx, request, params)
	return res, err
}

func (c *Client) sendSSOProfilesSSOProfileIDPut(ctx context.Context, request *SSOProfilesSSOProfileIDPutReq, params SSOProfilesSSOProfileIDPutParams) (res SSOProfilesSSOProfileIDPutRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/sso-profiles/"
	{
		// Encode "sso_profile_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "sso_profile_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.SSOProfileID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSSOProfilesSSOProfileIDPutRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, SSOProfilesSSOProfileIDPutOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSSOProfilesSSOProfileIDPutResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SSOProfilesSSOProfileIDUnassignPost invokes POST /sso-profiles/{sso_profile_id}/unassign operation.
//
// 指定したSSOプロファイルの割り当てを外す.
//
// POST /sso-profiles/{sso_profile_id}/unassign
func (c *Client) SSOProfilesSSOProfileIDUnassignPost(ctx context.Context, params SSOProfilesSSOProfileIDUnassignPostParams) (SSOProfilesSSOProfileIDUnassignPostRes, error) {
	res, err := c.sendSSOProfilesSSOProfileIDUnassignPost(ctx, params)
	return res, err
}

func (c *Client) sendSSOProfilesSSOProfileIDUnassignPost(ctx context.Context, params SSOProfilesSSOProfileIDUnassignPostParams) (res SSOProfilesSSOProfileIDUnassignPostRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/sso-profiles/"
	{
		// Encode "sso_profile_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "sso_profile_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.SSOProfileID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/unassign"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, SSOProfilesSSOProfileIDUnassignPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSSOProfilesSSOProfileIDUnassignPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ServicePolicyRuleTemplatesGet invokes GET /service-policy-rule-templates operation.
//
// ルールテンプレートの一覧を取得する.
//
// GET /service-policy-rule-templates
func (c *Client) ServicePolicyRuleTemplatesGet(ctx context.Context, params ServicePolicyRuleTemplatesGetParams) (ServicePolicyRuleTemplatesGetRes, error) {
	res, err := c.sendServicePolicyRuleTemplatesGet(ctx, params)
	return res, err
}

func (c *Client) sendServicePolicyRuleTemplatesGet(ctx context.Context, params ServicePolicyRuleTemplatesGetParams) (res ServicePolicyRuleTemplatesGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/service-policy-rule-templates"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Name.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "code" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "code",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Code.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Type.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, ServicePolicyRuleTemplatesGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeServicePolicyRuleTemplatesGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ServicePolicyStatusGet invokes GET /service-policy-status operation.
//
// サービスポリシーの有効状態を取得する.
//
// GET /service-policy-status
func (c *Client) ServicePolicyStatusGet(ctx context.Context) (ServicePolicyStatusGetRes, error) {
	res, err := c.sendServicePolicyStatusGet(ctx)
	return res, err
}

func (c *Client) sendServicePolicyStatusGet(ctx context.Context) (res ServicePolicyStatusGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/service-policy-status"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, ServicePolicyStatusGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeServicePolicyStatusGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ServicePrincipalsGet invokes GET /service-principals operation.
//
// サービスプリンシパル一覧を取得する.
//
// GET /service-principals
func (c *Client) ServicePrincipalsGet(ctx context.Context, params ServicePrincipalsGetParams) (ServicePrincipalsGetRes, error) {
	res, err := c.sendServicePrincipalsGet(ctx, params)
	return res, err
}

func (c *Client) sendServicePrincipalsGet(ctx context.Context, params ServicePrincipalsGetParams) (res ServicePrincipalsGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/service-principals"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "project_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "project_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ProjectID.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "ordering" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "ordering",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Ordering.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, ServicePrincipalsGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeServicePrincipalsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ServicePrincipalsOAuth2TokenPost invokes POST /service-principals/oauth2/token operation.
//
// 登録済みサービスプリンシパルキーの秘密鍵を使い、以下のようなJWTを署名してください。
// #### JWTのヘッダー
// ```json
// {
// "alg": "RS256",
// "kid": "$SERVICE_PRINCIPAL_KEY_KID",
// "typ": "JWT"
// }
// ```
// ### JWTのペイロード
// ```json
// {
// "aud": "https://secure.sakura.ad.jp/cloud/api/iam/1.0/service-principals/oauth2/token",
// "exp": 現在のUnix time + 5分,
// "iat": 現在のUnix time,
// "iss": "$SERVICE_PRINCIPAL_RESOURCE_ID",
// "sub": "$SERVICE_PRINCIPAL_RESOURCE_ID"
// }
// ```.
//
// POST /service-principals/oauth2/token
func (c *Client) ServicePrincipalsOAuth2TokenPost(ctx context.Context, request *ServicePrincipalJWTGrantRequest) (ServicePrincipalsOAuth2TokenPostRes, error) {
	res, err := c.sendServicePrincipalsOAuth2TokenPost(ctx, request)
	return res, err
}

func (c *Client) sendServicePrincipalsOAuth2TokenPost(ctx context.Context, request *ServicePrincipalJWTGrantRequest) (res ServicePrincipalsOAuth2TokenPostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/service-principals/oauth2/token"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeServicePrincipalsOAuth2TokenPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, ServicePrincipalsOAuth2TokenPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeServicePrincipalsOAuth2TokenPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ServicePrincipalsPost invokes POST /service-principals operation.
//
// サービスプリンシパルを作成する.
//
// POST /service-principals
func (c *Client) ServicePrincipalsPost(ctx context.Context, request *ServicePrincipalsPostReq) (ServicePrincipalsPostRes, error) {
	res, err := c.sendServicePrincipalsPost(ctx, request)
	return res, err
}

func (c *Client) sendServicePrincipalsPost(ctx context.Context, request *ServicePrincipalsPostReq) (res ServicePrincipalsPostRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/service-principals"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeServicePrincipalsPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, ServicePrincipalsPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeServicePrincipalsPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ServicePrincipalsServicePrincipalIDDelete invokes DELETE /service-principals/{service_principal_id} operation.
//
// 指定したサービスプリンシパルを削除する.
//
// DELETE /service-principals/{service_principal_id}
func (c *Client) ServicePrincipalsServicePrincipalIDDelete(ctx context.Context, params ServicePrincipalsServicePrincipalIDDeleteParams) (ServicePrincipalsServicePrincipalIDDeleteRes, error) {
	res, err := c.sendServicePrincipalsServicePrincipalIDDelete(ctx, params)
	return res, err
}

func (c *Client) sendServicePrincipalsServicePrincipalIDDelete(ctx context.Context, params ServicePrincipalsServicePrincipalIDDeleteParams) (res ServicePrincipalsServicePrincipalIDDeleteRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/service-principals/"
	{
		// Encode "service_principal_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "service_principal_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ServicePrincipalID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, ServicePrincipalsServicePrincipalIDDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeServicePrincipalsServicePrincipalIDDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ServicePrincipalsServicePrincipalIDGet invokes GET /service-principals/{service_principal_id} operation.
//
// 指定したサービスプリンシパルを取得する.
//
// GET /service-principals/{service_principal_id}
func (c *Client) ServicePrincipalsServicePrincipalIDGet(ctx context.Context, params ServicePrincipalsServicePrincipalIDGetParams) (ServicePrincipalsServicePrincipalIDGetRes, error) {
	res, err := c.sendServicePrincipalsServicePrincipalIDGet(ctx, params)
	return res, err
}

func (c *Client) sendServicePrincipalsServicePrincipalIDGet(ctx context.Context, params ServicePrincipalsServicePrincipalIDGetParams) (res ServicePrincipalsServicePrincipalIDGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/service-principals/"
	{
		// Encode "service_principal_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "service_principal_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ServicePrincipalID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, ServicePrincipalsServicePrincipalIDGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeServicePrincipalsServicePrincipalIDGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ServicePrincipalsServicePrincipalIDKeysGet invokes GET /service-principals/{service_principal_id}/keys operation.
//
// GET /service-principals/{service_principal_id}/keys
func (c *Client) ServicePrincipalsServicePrincipalIDKeysGet(ctx context.Context, params ServicePrincipalsServicePrincipalIDKeysGetParams) (ServicePrincipalsServicePrincipalIDKeysGetRes, error) {
	res, err := c.sendServicePrincipalsServicePrincipalIDKeysGet(ctx, params)
	return res, err
}

func (c *Client) sendServicePrincipalsServicePrincipalIDKeysGet(ctx context.Context, params ServicePrincipalsServicePrincipalIDKeysGetParams) (res ServicePrincipalsServicePrincipalIDKeysGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/service-principals/"
	{
		// Encode "service_principal_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "service_principal_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ServicePrincipalID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/keys"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerPage.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "ordering" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "ordering",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Ordering.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, ServicePrincipalsServicePrincipalIDKeysGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeServicePrincipalsServicePrincipalIDKeysGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ServicePrincipalsServicePrincipalIDKeysServicePrincipalKeyIDDelete invokes DELETE /service-principals/{service_principal_id}/keys/{service_principal_key_id} operation.
//
// 指定したサービスプリンシパルキーを削除する.
//
// DELETE /service-principals/{service_principal_id}/keys/{service_principal_key_id}
func (c *Client) ServicePrincipalsServicePrincipalIDKeysServicePrincipalKeyIDDelete(ctx context.Context, params ServicePrincipalsServicePrincipalIDKeysServicePrincipalKeyIDDeleteParams) (ServicePrincipalsServicePrincipalIDKeysServicePrincipalKeyIDDeleteRes, error) {
	res, err := c.sendServicePrincipalsServicePrincipalIDKeysServicePrincipalKeyIDDelete(ctx, params)
	return res, err
}

func (c *Client) sendServicePrincipalsServicePrincipalIDKeysServicePrincipalKeyIDDelete(ctx context.Context, params ServicePrincipalsServicePrincipalIDKeysServicePrincipalKeyIDDeleteParams) (res ServicePrincipalsServicePrincipalIDKeysServicePrincipalKeyIDDeleteRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/service-principals/"
	{
		// Encode "service_principal_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "service_principal_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ServicePrincipalID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/keys/"
	{
		// Encode "service_principal_key_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "service_principal_key_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ServicePrincipalKeyID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, ServicePrincipalsServicePrincipalIDKeysServicePrincipalKeyIDDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeServicePrincipalsServicePrincipalIDKeysServicePrincipalKeyIDDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ServicePrincipalsServicePrincipalIDKeysServicePrincipalKeyIDDisablePost invokes POST /service-principals/{service_principal_id}/keys/{service_principal_key_id}/disable operation.
//
// 指定したサービスプリンシパルキーを無効化する.
//
// POST /service-principals/{service_principal_id}/keys/{service_principal_key_id}/disable
func (c *Client) ServicePrincipalsServicePrincipalIDKeysServicePrincipalKeyIDDisablePost(ctx context.Context, params ServicePrincipalsServicePrincipalIDKeysServicePrincipalKeyIDDisablePostParams) (ServicePrincipalsServicePrincipalIDKeysServicePrincipalKeyIDDisablePostRes, error) {
	res, err := c.sendServicePrincipalsServicePrincipalIDKeysServicePrincipalKeyIDDisablePost(ctx, params)
	return res, err
}

func (c *Client) sendServicePrincipalsServicePrincipalIDKeysServicePrincipalKeyIDDisablePost(ctx context.Context, params ServicePrincipalsServicePrincipalIDKeysServicePrincipalKeyIDDisablePostParams) (res ServicePrincipalsServicePrincipalIDKeysServicePrincipalKeyIDDisablePostRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/service-principals/"
	{
		// Encode "service_principal_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "service_principal_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ServicePrincipalID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/keys/"
	{
		// Encode "service_principal_key_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "service_principal_key_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ServicePrincipalKeyID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/disable"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, ServicePrincipalsServicePrincipalIDKeysServicePrincipalKeyIDDisablePostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeServicePrincipalsServicePrincipalIDKeysServicePrincipalKeyIDDisablePostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ServicePrincipalsServicePrincipalIDKeysServicePrincipalKeyIDEnablePost invokes POST /service-principals/{service_principal_id}/keys/{service_principal_key_id}/enable operation.
//
// 指定したサービスプリンシパルキーを有効化する.
//
// POST /service-principals/{service_principal_id}/keys/{service_principal_key_id}/enable
func (c *Client) ServicePrincipalsServicePrincipalIDKeysServicePrincipalKeyIDEnablePost(ctx context.Context, params ServicePrincipalsServicePrincipalIDKeysServicePrincipalKeyIDEnablePostParams) (ServicePrincipalsServicePrincipalIDKeysServicePrincipalKeyIDEnablePostRes, error) {
	res, err := c.sendServicePrincipalsServicePrincipalIDKeysServicePrincipalKeyIDEnablePost(ctx, params)
	return res, err
}

func (c *Client) sendServicePrincipalsServicePrincipalIDKeysServicePrincipalKeyIDEnablePost(ctx context.Context, params ServicePrincipalsServicePrincipalIDKeysServicePrincipalKeyIDEnablePostParams) (res ServicePrincipalsServicePrincipalIDKeysServicePrincipalKeyIDEnablePostRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/service-principals/"
	{
		// Encode "service_principal_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "service_principal_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ServicePrincipalID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/keys/"
	{
		// Encode "service_principal_key_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "service_principal_key_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ServicePrincipalKeyID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/enable"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, ServicePrincipalsServicePrincipalIDKeysServicePrincipalKeyIDEnablePostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeServicePrincipalsServicePrincipalIDKeysServicePrincipalKeyIDEnablePostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ServicePrincipalsServicePrincipalIDPut invokes PUT /service-principals/{service_principal_id} operation.
//
// 指定したサービスプリンシパルを更新する.
//
// PUT /service-principals/{service_principal_id}
func (c *Client) ServicePrincipalsServicePrincipalIDPut(ctx context.Context, request *ServicePrincipalsServicePrincipalIDPutReq, params ServicePrincipalsServicePrincipalIDPutParams) (ServicePrincipalsServicePrincipalIDPutRes, error) {
	res, err := c.sendServicePrincipalsServicePrincipalIDPut(ctx, request, params)
	return res, err
}

func (c *Client) sendServicePrincipalsServicePrincipalIDPut(ctx context.Context, request *ServicePrincipalsServicePrincipalIDPutReq, params ServicePrincipalsServicePrincipalIDPutParams) (res ServicePrincipalsServicePrincipalIDPutRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/service-principals/"
	{
		// Encode "service_principal_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "service_principal_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ServicePrincipalID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeServicePrincipalsServicePrincipalIDPutRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, ServicePrincipalsServicePrincipalIDPutOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeServicePrincipalsServicePrincipalIDPutResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ServicePrincipalsServicePrincipalIDUploadKeyPost invokes POST /service-principals/{service_principal_id}/upload-key operation.
//
// ユーザ生成の鍵をサービスプリンシパルキーとして登録する.
//
// POST /service-principals/{service_principal_id}/upload-key
func (c *Client) ServicePrincipalsServicePrincipalIDUploadKeyPost(ctx context.Context, request OptServicePrincipalsServicePrincipalIDUploadKeyPostReq, params ServicePrincipalsServicePrincipalIDUploadKeyPostParams) (ServicePrincipalsServicePrincipalIDUploadKeyPostRes, error) {
	res, err := c.sendServicePrincipalsServicePrincipalIDUploadKeyPost(ctx, request, params)
	return res, err
}

func (c *Client) sendServicePrincipalsServicePrincipalIDUploadKeyPost(ctx context.Context, request OptServicePrincipalsServicePrincipalIDUploadKeyPostReq, params ServicePrincipalsServicePrincipalIDUploadKeyPostParams) (res ServicePrincipalsServicePrincipalIDUploadKeyPostRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/service-principals/"
	{
		// Encode "service_principal_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "service_principal_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.IntToString(params.ServicePrincipalID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/upload-key"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeServicePrincipalsServicePrincipalIDUploadKeyPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityCompatAccessTokenAuth(ctx, ServicePrincipalsServicePrincipalIDUploadKeyPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"CompatAccessTokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeServicePrincipalsServicePrincipalIDUploadKeyPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
